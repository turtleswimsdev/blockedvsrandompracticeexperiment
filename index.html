
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 1. Page Title -->
    <title>Anticipation vs. Reaction Time Training</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 2.A. Color Variables (Custom CSS) */
        :root {
            --color-bg-light: #f3f4f6; /* gray-100 */
            --color-bg-mid: #e5e7eb; /* gray-200 */
            --color-text-dark: #1f2937; /* gray-800 */
            --color-flash-blue: #3b82f6; /* blue-500 - Note: This is still used for the cue flash color */
            --color-border: #9ca3af; /* gray-400 */
        }

        /* 2.B. Reaction Box and Text Styling */
        #reaction-box {
            /* 17. Size & Constraint */
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 80vh; 
            /* 18. Default Style */
            background-color: var(--color-bg-mid);
            border: 4px solid var(--color-border);
            border-radius: 1rem;
            /* 19. Shadow */
            box-shadow: 0 10px 15px 3px rgba(0, 0, 0, 0.1), 0 4px 6px 2px rgba(0, 0, 0, 0.05);
            /* 20. Default Content Text */
            font-size: 3rem;
            font-weight: 800;
            color: var(--color-text-dark);
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
        }

        /* 2.C. Blue Cue State (.flash-cue) */
        .flash-cue {
            /* 23. background-color */
            background-color: var(--color-flash-blue) !important; 
            /* 24. color */
            color: white !important; 
            /* 25. border-color */
            border-color: var(--color-flash-blue) !important;
        }

        /* 21. Countdown Text Size - Sizing Fix Implemented Here */
        #countdown-text {
            /* Default font size is now consistently 3rem (smaller) */
            font-size: 3rem; 
            min-width: 500px; 
            display: inline-block;
            transition: none; 
        }
        
        /* 9. Main Application Layout */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-light);
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- 2.B. Status Bar (h-16) -->
    <header class="h-16 flex items-center justify-between px-6 z-10 bg-white border-b border-gray-200 shadow-md relative">
        <div id="last-rt-display" class="text-sm font-semibold text-gray-600">
            Last RT: -- ms
        </div>

        <!-- 12. Center Status (#status-display) -->
        <div id="status-display" class="text-lg font-bold text-gray-800 absolute left-1/2 transform -translate-x-1/2">
            Ready
        </div>

        <!-- 13. Pause/Resume Button (#btn-pause-resume) -->
        <button id="btn-pause-resume" 
                class="w-10 h-10 text-2xl bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 transition duration-150 shadow-inner disabled:opacity-50"
                disabled
                title="Pause/Resume Game">
            ⏸
        </button>
    </header>

    <!-- Options Bar -->
    <nav id="options-bar" class="p-3 bg-gray-50 border-b border-gray-200">
        <!-- 15. Button Layout -->
        <div class="flex gap-3 flex-wrap justify-center">
            
            <!-- Training & Test Buttons -->
            <button id="btn-fixed-practice" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Training Set A
            </button>
            <button id="btn-variable-practice" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Training Set B
            </button>
            <button id="btn-test-variable" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Reaction Test 1
            </button>
            <button id="btn-test-fixed" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Reaction Test 2
            </button>
            <button id="btn-results" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                View Results
            </button>
        </div>
    </nav>

    <!-- 16. Reaction Area Container -->
    <main id="reaction-area-container" class="flex-1 flex items-center justify-center p-4">
        <!-- Reaction Box -->
        <div id="reaction-box" class="flex items-center justify-center text-center p-8" onclick="window.handleReaction(event)">
            <!-- 44. Initial Content Text -->
            <span id="countdown-text">Welcome</span>
        </div>
    </main>

    <!-- Results Modal (Hidden) - Updated to a Single View -->
    <div id="results-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
        <!-- Main Content Panel (Full Width and Height) -->
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-800">
                All Historical Session Results
            </h2>
            
            <!-- Export Status Display -->
            <div id="export-status" class="hidden p-3 mb-4 text-sm font-semibold rounded-lg"></div>

            <!-- Main Content Area -->
            <div id="session-details-content" class="text-sm flex-1 overflow-y-auto">
                
                <!-- Summary Area (Always Visible: Totals for ALL sessions) -->
                <div id="summary-area" class="mb-4 space-y-1 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <p class="text-xs text-gray-500">Totals calculated from all sessions below.</p>
                    <p>Participant: <span id="participant-name" class="font-medium">--</span></p>
                    <p>Total Sessions: <span id="results-total-sessions" class="font-medium">--</span></p>
                    <p>Total Rounds: <span id="results-total-rounds" class="font-medium">--</span></p>
                    <p class="mt-2 text-base font-semibold">
                        Overall Average RT: <span id="results-avg-rt" class="text-green-600">--</span> ms | 
                        Total Hits: <span id="results-hits" class="text-green-600">--</span> | 
                        Total False Starts: <span id="results-false-starts" class="text-red-600">--</span> | 
                        Total Missed: <span id="results-missed" class="text-yellow-600">--</span>
                    </p>
                </div>
                
                <h3 class="text-lg font-semibold mt-6 mb-2">Unified Round Breakdown (Ordered by Experiment Phase)</h3>
                <div id="results-loading-message" class="text-center p-8 text-gray-500">Loading results...</div>

                <div class="overflow-x-auto">
                    <table id="results-table" class="min-w-full divide-y divide-gray-200 mb-6 hidden">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Round</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Reaction Time (ms)</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200" id="results-table-body">
                            <!-- Details loaded here sequentially -->
                        </tbody>
                    </table>
                </div>
                
            </div>
            <!-- Close Button -->
            <div class="mt-auto pt-4 border-t flex justify-between">
                <!-- UPDATED EXPORT BUTTON to call the CSV download function -->
                <button id="btn-export-data" 
                        onclick="window.downloadResultsAsCSV()" 
                        class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 disabled:opacity-50" 
                        disabled>
                    Download Data as CSV
                </button>

                <button onclick="document.getElementById('results-modal').classList.add('hidden')" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-lg transition duration-200">Close</button>
            </div>
        </div>
    </div>

    <!-- 2. Initial State: Participant Information Modal -->
    <div id="info-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md">
            <!-- 50. Info Modal Title -->
            <h2 class="text-2xl font-bold mb-6">Participant Information</h2>
            <form id="participant-form">
                <div class="mb-4">
                    <!-- 51. Info Modal Name Label - UPDATED: Removed descriptive text -->
                    <label for="full-name" class="block text-sm font-medium text-gray-700 mb-1">Full Name</label>
                    <input type="text" id="full-name" name="fullName" required class="mt-1 block w-full border border-gray-300 rounded-lg shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                    <!-- UPDATED: Added dedicated error display -->
                    <div id="name-error" class="text-red-500 text-xs mt-1 hidden" role="alert"></div>
                </div>
                <div class="mb-4">
                    <!-- 52. Info Modal Grade Label -->
                    <label for="grade-level" class="block text-sm font-medium text-gray-700 mb-1">Grade Level (Number Only, 1-12)</label>
                    <input type="number" id="grade-level" name="gradeLevel" min="1" max="12" required class="mt-1 block w-full border border-gray-300 rounded-lg shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="mb-6">
                    <span class="block text-sm font-medium text-gray-700 mb-2">Sex</span>
                    <!-- 53. Info Modal Sex Options -->
                    <div class="flex space-x-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="sex" value="Male" required class="form-radio h-4 w-4 text-blue-600">
                            <span class="ml-2 text-gray-700">Male</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="sex" value="Female" required class="form-radio h-4 w-4 text-blue-600">
                            <span class="ml-2 text-gray-700">Female</span>
                        </label>
                    </div>
                </div>
                <!-- 54. Info Modal Button -->
                <button id="btn-start-experiment" type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-lg">
                    Start Experiment
                </button>
            </form>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, collection, query, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Variables (Mandatory) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Game Setup ---
        let app, db, auth, userId = null;

        // NEW GLOBAL: To hold fetched results temporarily for export
        window.lastFetchedResults = []; 

        // NOTE: The GAS_WEB_APP_URL is no longer needed for CSV download, but kept here for reference.
        // const GAS_WEB_APP_URL = "YOUR_APPS_SCRIPT_WEB_APP_URL_HERE"; 
        
        /**
         * Initializes Firebase and authenticates the user.
         */
        async function initFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing or empty. Data will not persist across sessions.");
                    return;
                }
                
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase authenticated. User ID:", userId);
                    } else {
                        userId = crypto.randomUUID(); 
                        console.warn("User not authenticated. Using random UUID for user ID.");
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                userId = crypto.randomUUID(); // Fallback
            }
        }
        
        /**
         * Saves the current session's results to Firestore.
         */
        window.saveResults = async function(mode, totalRounds, results) {
            if (!db || !userId) {
                console.error("Database not initialized or User ID not set. Cannot save.");
                return;
            }

            const dataToSave = {
                appId: appId,
                userId: userId,
                participant: window.gameState.participant, // Save participant info with results
                mode: mode,
                totalRounds: totalRounds,
                timestamp: serverTimestamp(),
                results: results
            };

            const path = `/artifacts/${appId}/users/${userId}/results`;
            try {
                await addDoc(collection(db, path), dataToSave);
                console.log("Session results saved successfully.");
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        };

        // Helper to format mode for display
        function formatMode(mode) {
            switch (mode) {
                case 'fixed-practice':
                    return 'Training Set A (Fixed)';
                case 'variable-practice':
                    return 'Training Set B (Variable)';
                case 'variable-test':
                    return 'Reaction Test 1 (Variable Cue)';
                case 'fixed-test':
                    return 'Reaction Test 2 (Fixed Cue)';
                default:
                    return mode;
            }
        }
        
        /**
         * Fetches and displays ALL historical results in a single, unified view.
         */
        window.showAllHistoricalResults = async function() {
            if (!db || !userId) {
                console.error("Database not initialized or User ID not set. Cannot view results.");
                return;
            }

            const loadingMessage = document.getElementById('results-loading-message');
            const resultsTable = document.getElementById('results-table');
            const resultsTableBody = document.getElementById('results-table-body');
            const btnExport = document.getElementById('btn-export-data');
            const exportStatus = document.getElementById('export-status');
            
            loadingMessage.classList.remove('hidden');
            resultsTable.classList.add('hidden');
            resultsTableBody.innerHTML = '';
            btnExport.disabled = true; // Disable export until data is loaded
            exportStatus.classList.add('hidden'); // Clear status

            window.lastFetchedResults = []; // Clear previous data
            
            const path = `/artifacts/${appId}/users/${userId}/results`;
            
            try {
                const q = query(collection(db, path));
                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    loadingMessage.textContent = 'No past sessions found.';
                    document.getElementById('results-modal').classList.remove('hidden');
                    return;
                }

                const modeOrder = {
                    'fixed-practice': 1,
                    'variable-practice': 1,
                    'variable-test': 2,
                    'fixed-test': 3
                };

                let allSessions = [];
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    // Get timestamp in milliseconds for secondary chronological sorting
                    const timestampMs = data.timestamp ? (data.timestamp.toMillis ? data.timestamp.toMillis() : 0) : 0;
                    allSessions.push({ id: doc.id, ...data, timestampMs });
                });

                // Store data globally for export function
                window.lastFetchedResults = allSessions; 
                btnExport.disabled = false; // Enable export

                // Sort the sessions: primarily by experiment mode order, secondarily by timestamp (oldest first)
                allSessions.sort((a, b) => {
                    const orderA = modeOrder[a.mode] || 99;
                    const orderB = modeOrder[b.mode] || 99;
                    
                    // 1. Sort primarily by defined order (Training -> Test 1 -> Test 2)
                    if (orderA !== orderB) {
                        return orderA - orderB;
                    }
                    
                    // 2. Secondary sort: within the same mode group, sort chronologically (oldest first)
                    return a.timestampMs - b.timestampMs;
                });

                // --- 1. Calculate Global Summary Statistics ---
                let totalHits = 0;
                let totalFalseStarts = 0;
                let totalMissed = 0;
                let totalRounds = 0;
                let allRts = [];
                let participantName = allSessions[0].participant?.fullName || 'N/A';
                
                allSessions.forEach(session => {
                    session.results.forEach(result => {
                        if (result.status === 'HIT' && result.rt !== null) {
                            allRts.push(result.rt);
                        }
                    });
                    totalRounds += session.totalRounds;
                    totalHits += session.results.filter(r => r.status === 'HIT').length;
                    totalFalseStarts += session.results.filter(r => r.status === 'FALSE START').length;
                    totalMissed += session.results.filter(r => r.status === 'MISSED').length;
                });
                
                const overallAvgRt = allRts.length > 0 ? (allRts.reduce((a, b) => a + b, 0) / allRts.length).toFixed(0) : '--';

                // --- 2. Update Summary Area ---
                document.getElementById('participant-name').textContent = participantName; 
                document.getElementById('results-total-sessions').textContent = allSessions.length;
                document.getElementById('results-total-rounds').textContent = totalRounds;
                document.getElementById('results-avg-rt').textContent = overallAvgRt;
                document.getElementById('results-hits').textContent = totalHits;
                document.getElementById('results-false-starts').textContent = totalFalseStarts;
                document.getElementById('results-missed').textContent = totalMissed;

                // --- 3. Populate Unified Breakdown Table ---
                allSessions.forEach((session, sessionIndex) => {
                    const displayMode = formatMode(session.mode);
                    
                    // A. Add Session Header Row 
                    const sessionHits = session.results.filter(r => r.status === 'HIT');
                    const sessionAvgRt = sessionHits.length > 0 ? (sessionHits.map(r => r.rt).reduce((a, b) => a + b, 0) / sessionHits.length).toFixed(0) : '--';
                    
                    const headerRow = resultsTableBody.insertRow();
                    headerRow.className = 'text-sm bg-blue-100 font-bold border-t-4 border-blue-400';
                    headerRow.innerHTML = `
                        <td class="px-3 py-2 whitespace-nowrap" colspan="4">
                            ${displayMode} (Session Avg RT: ${sessionAvgRt} ms)
                        </td>
                    `;

                    // B. Add Round Breakdown (Sequential)
                    session.results.forEach((result, index) => {
                        const row = resultsTableBody.insertRow();
                        // Alternate background colors per row for readability
                        row.className = 'text-sm ' + (index % 2 === 0 ? 'bg-white' : 'bg-gray-50'); 
                        
                        const rtDisplay = result.rt !== null ? result.rt.toFixed(0) : '--';
                        let statusClass = 'text-gray-500';
                        if (result.status === 'HIT') statusClass = 'text-green-600 font-bold';
                        else if (result.status === 'FALSE START') statusClass = 'text-red-600 font-bold';

                        row.innerHTML = `
                            <td class="px-3 py-2 whitespace-nowrap">${displayMode}</td>
                            <td class="px-3 py-2 whitespace-nowrap">${result.round}</td>
                            <td class="px-3 py-2 whitespace-nowrap">${rtDisplay}</td>
                            <td class="px-3 py-2 whitespace-nowrap">
                                <span class="${statusClass}">${result.status}</span>
                            </td>
                        `;
                    });
                    
                    // C. Add False Start Summary Row (Separator)
                    const falseStartCount = session.results.filter(r => r.status === 'FALSE START').length;
                    const summaryRow = resultsTableBody.insertRow();
                    // Use a light yellow and a stronger bottom border to act as a clear separator
                    summaryRow.className = 'text-base bg-yellow-100 font-semibold border-b-2 border-yellow-400'; 
                    summaryRow.innerHTML = `
                        <td class="px-3 py-2 whitespace-nowrap" colspan="3">Total False Starts for ${displayMode}:</td>
                        <td class="px-3 py-2 whitespace-nowrap text-red-600">${falseStartCount}</td>
                    `;
                });
                
                loadingMessage.classList.add('hidden');
                resultsTable.classList.remove('hidden');

                document.getElementById('results-modal').classList.remove('hidden');

            } catch (error) {
                console.error("Error fetching results: ", error);
                loadingMessage.textContent = 'Error loading data. Check console for details.';
                document.getElementById('results-modal').classList.remove('hidden');
                btnExport.disabled = true;
            }
        };

        /**
         * Converts the last fetched data (from Firestore) into a CSV file and triggers a download.
         */
        window.downloadResultsAsCSV = function() {
            if (window.lastFetchedResults.length === 0) {
                console.error("No results to export.");
                const status = document.getElementById('export-status');
                status.textContent = 'No data available to download.';
                status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-red-100 text-red-700';
                status.classList.remove('hidden');
                return;
            }
            
            const btnExport = document.getElementById('btn-export-data');
            const status = document.getElementById('export-status');

            status.textContent = 'Preparing CSV file...';
            status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-blue-100 text-blue-700';
            status.classList.remove('hidden');
            btnExport.disabled = true;

            // Define the CSV Headers (Must match the Google Sheet column headers)
            const headers = [
                'Session ID', 'Timestamp (ISO)', 'Participant Name', 'Grade', 'Sex', 
                'Training/Test Type', 'Mode', 'Round Number', 'Reaction Time (ms)', 'Status', 
                'Interval Duration (ms)'
            ];
            
            let csvContent = headers.join(',') + '\n';
            const participantNameForFile = window.lastFetchedResults[0].participant?.fullName.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'participant';

            // Flatten and convert data rows
            window.lastFetchedResults.forEach(session => {
                const participant = session.participant;
                const sessionId = session.id;
                // Format timestamp for CSV
                const timestamp = session.timestamp ? new Date(session.timestamp.toMillis()).toISOString() : 'N/A';
                
                session.results.forEach(result => {
                    const row = [
                        // Ensure no commas or quotes mess up the CSV structure
                        `"${sessionId}"`,
                        timestamp,
                        `"${participant.fullName}"`,
                        participant.gradeLevel,
                        participant.sex,
                        session.mode.includes('practice') ? 'Training' : 'Test', // Training/Test Type
                        `"${formatMode(session.mode)}"`,
                        result.round,
                        result.rt !== null ? result.rt.toFixed(0) : 'N/A',
                        result.status,
                        result.interval || 'N/A'
                    ];
                    csvContent += row.join(',') + '\n';
                });
            });

            try {
                // 1. Create a Blob (Binary Large Object) containing the CSV content
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                
                // 2. Create a download link element
                const link = document.createElement('a');
                
                // 3. Set the file name (e.g., alex_johnson_rt_data_20251019.csv)
                const dateString = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                link.download = `${participantNameForFile}_rt_data_${dateString}.csv`;
                
                // 4. Set the href to the blob URL
                link.href = URL.createObjectURL(blob);
                
                // 5. Simulate a click to trigger the download
                link.click();
                
                // Clean up the URL object
                URL.revokeObjectURL(link.href);

                status.textContent = `Success! The file "${link.download}" has been downloaded.`;
                status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-green-100 text-green-700';
                
            } catch (error) {
                console.error("Error generating or downloading CSV:", error);
                status.textContent = `Error during download: ${error.message}`;
                status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-red-100 text-red-700';
            } finally {
                btnExport.disabled = false;
            }
        };


        // Initialize Firebase on load
        window.addEventListener('load', initFirebase);
    </script>

    <script>
        // ... (Remaining JavaScript remains the same) ...
        // --- 3.A. Game Constants ---
        const FIXED_INTERVAL_MS = 3500; 
        const PRACTICE_ROUNDS = 30; 
        const SINGLE_ROUND = 1; 
        const MISSED_TIMEOUT_MS = 10000; 
        const POST_TRIAL_DELAY_MS = 1500; 
        
        // --- 3.B. Variable Intervals (Mandatory Array) ---
        const VARIABLE_INTERVALS_MS = [
            1840, 2190, 3970, 5320, 2780, 4260, 1370, 3440, 2550, 5750,
            3690, 1220, 4580, 5010, 2070, 3120, 4970, 1660, 2900, 3830,
            2680, 4330, 2450, 5190, 1080, 3570, 2360, 4810, 5440, 1930
        ];

        // --- DOM Elements ---
        const infoModal = document.getElementById('info-modal');
        const participantForm = document.getElementById('participant-form');
        const reactionBox = document.getElementById('reaction-box');
        const countdownText = document.getElementById('countdown-text');
        const statusDisplay = document.getElementById('status-display');
        const lastRtDisplay = document.getElementById('last-rt-display');
        const btnPauseResume = document.getElementById('btn-pause-resume');
        const btnFixedPractice = document.getElementById('btn-fixed-practice');
        const btnVariablePractice = document.getElementById('btn-variable-practice');
        const btnTestVariable = document.getElementById('btn-test-variable');
        const btnTestFixed = document.getElementById('btn-test-fixed');
        const btnResults = document.getElementById('btn-results');
        
        // UPDATED: New DOM references for validation
        const fullNameInput = document.getElementById('full-name');
        const nameErrorDisplay = document.getElementById('name-error');

        // --- Game State (Updated with sequential flags) ---
        window.gameState = {
            participant: null, 
            mode: 'none', 
            isRunning: false,
            isPaused: false,
            isWaitingForCue: false,
            isWaitingForReaction: false,
            
            hasStartedFixedPractice: false,
            hasStartedVariablePractice: false,
            hasCompletedTraining: false, 
            hasCompletedTest1: false, 
            isSessionComplete: false, 
            
            currentRound: 0,
            totalRounds: 0,
            intervalArray: [], 
            intervalIndex: 0,
            timers: {
                countdown: null,
                cue: null,
                timeout: null,
                delay: null
            },
            startTime: 0, 
            cueTime: 0, 
            results: []
        };
        let gameState = window.gameState; 

        // --- Utility Functions ---
        
        /**
         * Fisher-Yates (Knuth) Shuffle for randomizing array elements.
         */
        function randomizeArray(array) {
            let currentIndex = array.length, randomIndex;
            let arr = [...array]; // Create a copy
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [arr[currentIndex], arr[randomIndex]] = [
                    arr[currentIndex], arr[randomIndex]
                ];
            }
            return arr;
        }

        /**
         * Updates the central status display.
         */
        function updateStatus(text, color = 'text-gray-800') {
            statusDisplay.textContent = text;
            statusDisplay.className = `text-lg font-bold absolute left-1/2 transform -translate-x-1/2 ${color}`;
        }
        
        /**
         * Clears all active timeouts and intervals.
         */
        function clearAllTimers() {
            Object.values(gameState.timers).forEach(timer => {
                if (timer) clearTimeout(timer);
                if (timer) clearInterval(timer);
            });
            gameState.timers = { countdown: null, cue: null, timeout: null, delay: null };
        }

        // --- UI State Management (Updated for sequential flow) ---

        /**
         * Enables/disables mode selection buttons based on sequential rules.
         */
        function updateModeButtons() {
            const disableAllModes = gameState.isRunning || gameState.isPaused;

            const hasStartedAnyTraining = gameState.hasStartedFixedPractice || gameState.hasStartedVariablePractice;
            
            btnFixedPractice.disabled = disableAllModes || hasStartedAnyTraining;
            btnVariablePractice.disabled = disableAllModes || hasStartedAnyTraining;
            
            btnTestVariable.disabled = disableAllModes || !gameState.hasCompletedTraining || gameState.hasCompletedTest1;
            
            btnTestFixed.disabled = disableAllModes || !gameState.hasCompletedTest1;

            // Pause/Resume button state
            btnPauseResume.disabled = !gameState.isRunning;
            if (gameState.isPaused) {
                btnPauseResume.textContent = '▶'; // Show Play icon when paused
            } else {
                btnPauseResume.textContent = '⏸'; // Show Pause icon when running
            }
        }

        /**
         * Manages the pause/resume state and button icon.
         */
        function togglePause() {
            if (!gameState.isRunning) return;

            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                // Pause Logic
                clearAllTimers();
                reactionBox.classList.remove('flash-cue'); 
                countdownText.textContent = 'Paused';
                updateStatus('Paused', 'text-orange-500');
            } else {
                // Resume Logic
                updateStatus(`Resumed. Restarting Round ${gameState.currentRound}...`, 'text-green-500');
                gameState.timers.delay = setTimeout(restartCurrentRound, 500); 
            }
            updateModeButtons();
        }

        /**
         * Function to restart the current round's sequence (used for False Starts and Resuming).
         */
        function restartCurrentRound() {
            if (gameState.isPaused || !gameState.isRunning) return;
            startCountdown();
        }

        /**
         * Executes the blue flash cue and starts the reaction timer.
         */
        function cueFlash() {
            gameState.cueTime = Date.now();
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = true;
            
            // Apply Blue Cue State
            reactionBox.classList.add('flash-cue');
            countdownText.textContent = ''; 
            updateStatus('REACT NOW!', 'text-blue-500');

            // Missed Trial Timeout (10 seconds)
            gameState.timers.timeout = setTimeout(handleTimeout, MISSED_TIMEOUT_MS);
        }

        /**
         * Starts the 3-2-1 countdown sequence.
         */
        function startCountdown() {
            if (gameState.isPaused || !gameState.isRunning) return;

            let count = 3;
            reactionBox.classList.remove('flash-cue', 'bg-red-400', 'text-white');
            countdownText.textContent = count;
            updateStatus(`Round ${gameState.currentRound}/${gameState.totalRounds}. Get Ready...`);
            
            if (gameState.timers.countdown) clearInterval(gameState.timers.countdown);

            gameState.timers.countdown = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else {
                    clearInterval(gameState.timers.countdown);
                    countdownText.textContent = ''; 
                    updateStatus('WAIT for the flash', 'text-gray-700');
                    startRoundTimer();
                }
            }, 1000);
        }

        /**
         * Advances to the next round or ends the session.
         */
        function nextRound() {
            if (gameState.isPaused || !gameState.isRunning || gameState.isSessionComplete) return;

            gameState.currentRound++; 
            
            if (gameState.currentRound > gameState.totalRounds) {
                endSession();
                return;
            }
            
            if (gameState.mode === 'variable-practice') {
                gameState.intervalIndex++;
            }
            
            startCountdown();
        }

        /**
         * Cleans up after a session and saves results. 
         */
        function endSession() {
            clearAllTimers();
            gameState.isRunning = false;
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = false;
            gameState.isSessionComplete = true; 

            // Save results
            window.saveResults(gameState.mode, gameState.totalRounds, gameState.results);

            let message = '';
            let statusColor = '';
            
            if (gameState.mode === 'fixed-practice' || gameState.mode === 'variable-practice') { 
                gameState.hasCompletedTraining = true;
                message = 'Training Complete!';
                statusColor = 'text-green-700';
            } else if (gameState.mode === 'variable-test') {
                gameState.hasCompletedTest1 = true;
                message = 'Test 1 Complete!';
                statusColor = 'text-green-700';
            } else if (gameState.mode === 'fixed-test') {
                message = 'All Tests Complete!';
                statusColor = 'text-blue-700';
            }

            // UI updates
            countdownText.textContent = message;
            updateStatus(message, statusColor);
            updateModeButtons();
            
            // Automatically show results for the completed session
            window.showAllHistoricalResults();
        }

        /**
         * Handles a successful reaction (HIT).
         */
        function handleHit() {
            clearTimeout(gameState.timers.timeout); 

            const reactionTime = Date.now() - gameState.cueTime;
            const interval = gameState.cueTime - gameState.startTime;

            // Record Result
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: interval,
                rt: reactionTime,
                status: 'HIT'
            });

            // Display Feedback
            reactionBox.classList.remove('flash-cue');
            countdownText.textContent = `${reactionTime.toFixed(0)} ms`;
            lastRtDisplay.textContent = `Last RT: ${reactionTime.toFixed(0)} ms`;
            updateStatus('HIT!', 'text-green-600');
            
            gameState.isWaitingForReaction = false;

            // Next Round (increments round count)
            gameState.timers.delay = setTimeout(nextRound, POST_TRIAL_DELAY_MS);
        }

        function handleFalseStart() {
            clearAllTimers();
            
            // Record Result
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: null,
                rt: null,
                status: 'FALSE START'
            });

            // False Start Feedback (flash red for 500ms)
            countdownText.textContent = 'FALSE START';
            reactionBox.classList.add('bg-red-400', 'text-white');
            reactionBox.classList.remove('flash-cue');
            updateStatus('FALSE START! Restarting round...', 'text-red-600');
            
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(() => {
                // Restart the same round
                restartCurrentRound(); 
            }, 500); // 500ms flash
        }
        
        function handleTimeout() {
            clearAllTimers();
            
            // Record Result
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: gameState.cueTime - gameState.startTime,
                rt: null,
                status: 'MISSED'
            });

            // Display Feedback
            countdownText.textContent = 'MISSED';
            reactionBox.classList.remove('flash-cue');
            updateStatus('MISSED! Starting next round...', 'text-yellow-600');
            
            gameState.isWaitingForReaction = false;

            // Next Round (increments round count)
            gameState.timers.delay = setTimeout(nextRound, POST_TRIAL_DELAY_MS);
        }

        function startRoundTimer() {
            gameState.isWaitingForCue = true;
            gameState.startTime = Date.now();

            let interval;
            
            if (gameState.mode === 'variable-test') {
                 interval = 2360; // 2.36 seconds
            } 
            else if (gameState.mode === 'fixed-practice' || gameState.mode === 'fixed-test') {
                interval = FIXED_INTERVAL_MS; 
            } 
            else if (gameState.mode === 'variable-practice') {
                interval = gameState.intervalArray[gameState.intervalIndex];
            } else {
                console.error("Unknown game mode:", gameState.mode);
                interval = FIXED_INTERVAL_MS;
            }

            gameState.timers.cue = setTimeout(cueFlash, interval);
        }

        function startSession(mode, totalRounds) {
            if (gameState.isSessionComplete && gameState.isRunning) return; 

            clearAllTimers();

            if (mode === 'fixed-practice') gameState.hasStartedFixedPractice = true;
            if (mode === 'variable-practice') gameState.hasStartedVariablePractice = true;
            
            // Reset State
            gameState.mode = mode;
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.isSessionComplete = false; 
            gameState.currentRound = 0; 
            gameState.totalRounds = totalRounds;
            gameState.results = [];
            
            if (mode === 'variable-practice') {
                gameState.intervalArray = randomizeArray(VARIABLE_INTERVALS_MS);
                gameState.intervalIndex = 0;
            } else {
                gameState.intervalArray = [];
                gameState.intervalIndex = 0;
            }

            // UI updates
            btnPauseResume.disabled = false;
            updateModeButtons();
            
            nextRound(); 
        }

        /**
         * Core function to handle a user click or spacebar press.
         */
        window.handleReaction = function(event) {
            if (gameState.isPaused || !gameState.isRunning || gameState.isSessionComplete) return;

            if (gameState.isWaitingForReaction) {
                handleHit();
            } else if (gameState.isWaitingForCue) {
                handleFalseStart();
            } else {
                console.log("Reaction ignored. Not cue or reaction phase.");
            }
        }


        // --- Event Listeners and Initialization ---

        // Participant Modal Submission
        participantForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            
            const fullName = formData.get('fullName').trim();
            const gradeLevel = parseInt(formData.get('gradeLevel'));
            
            nameErrorDisplay.classList.add('hidden'); // Clear previous errors

            // UPDATED: Name validation with explicit feedback
            const nameRegex = /^[A-Za-z\s.'-]+$/; 
            
            if (fullName.length < 2) {
                nameErrorDisplay.textContent = "Please enter your full name (at least two characters).";
                nameErrorDisplay.classList.remove('hidden');
                return; 
            }
            
            if (!nameRegex.test(fullName)) {
                nameErrorDisplay.textContent = "Name contains invalid characters. Use only letters, spaces, hyphens, apostrophes, or periods.";
                nameErrorDisplay.classList.remove('hidden');
                return; 
            }
            
            if (gradeLevel < 1 || gradeLevel > 12) {
                // If a grade error occurs, we still only use console.error for consistency, 
                // as the user only requested changes for the name field.
                console.error("Grade level out of range.");
                return; 
            }
            
            gameState.participant = {
                fullName: fullName,
                gradeLevel: gradeLevel,
                sex: formData.get('sex')
            };

            infoModal.classList.add('hidden');
            countdownText.textContent = 'Welcome';
            updateStatus('Ready. Choose a Training Set.');
            updateModeButtons(); 
        });

        // Mode Buttons Click
        document.querySelectorAll('.btn-mode').forEach(button => {
            button.addEventListener('click', (e) => {
                if (e.target.disabled) return; 

                const id = e.target.id;
                let mode, rounds;

                if (id === 'btn-fixed-practice') { 
                    mode = 'fixed-practice';
                    rounds = PRACTICE_ROUNDS;
                } else if (id === 'btn-variable-practice') { 
                    mode = 'variable-practice';
                    rounds = PRACTICE_ROUNDS;
                } else if (id === 'btn-test-variable') { 
                    mode = 'variable-test';
                    rounds = SINGLE_ROUND; 
                } else if (id === 'btn-test-fixed') { 
                    mode = 'fixed-test';
                    rounds = SINGLE_ROUND; 
                } else { 
                    return;
                }

                if (gameState.participant) {
                    startSession(mode, rounds);
                } else {
                    countdownText.textContent = "Please provide participant info first.";
                    updateStatus('Start Experiment Required', 'text-red-500');
                    infoModal.classList.remove('hidden');
                }
            });
        });

        // Pause/Resume Button
        btnPauseResume.addEventListener('click', togglePause);

        // View Results Button 
        btnResults.addEventListener('click', () => {
            window.showAllHistoricalResults();
        });

        // Reaction Area Click 
        reactionBox.addEventListener('click', window.handleReaction);

        // Global Spacebar Listener
        document.onkeydown = function(e) {
            if (e.key === ' ' || e.key === 'Spacebar') {
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'BUTTON') {
                    return;
                }
                e.preventDefault(); 
                window.handleReaction(e); 
            }
        };

        // --- Tab Focus/Blur Handlers (Pause on Blur, Manual Resume) ---
        window.addEventListener('blur', () => {
            if (gameState.isRunning && !gameState.isPaused) {
                // Auto-pause when tab loses focus
                togglePause(); 
            }
        });
        
        // Initial UI setup
        updateStatus('Ready');
        updateModeButtons();
    </script>
</body>
</html>



