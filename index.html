<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anticipation vs. Reaction Time Training</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 2.A. Color Variables (Custom CSS) */
        :root {
            --color-bg-light: #f3f4f6; /* gray-100 */
            --color-bg-mid: #e5e7eb; /* gray-200 */
            --color-text-dark: #1f2937; /* gray-800 */
            --color-flash-blue: #3b82f6; /* blue-500 - Note: This is still used for the cue flash color */
            --color-border: #9ca3af; /* gray-400 */
        }

        /* 2.B. Reaction Box and Text Styling */
        #reaction-box {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 80vh; 
            background-color: var(--color-bg-mid);
            border: 4px solid var(--color-border);
            border-radius: 1rem;
            box-shadow: 0 10px 15px 3px rgba(0, 0, 0, 0.1), 0 4px 6px 2px rgba(0, 0, 0, 0.05);
            font-size: 3rem;
            font-weight: 800;
            color: var(--color-text-dark);
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
        }

        /* 2.C. Blue Cue State (.flash-cue) */
        .flash-cue {
            background-color: var(--color-flash-blue) !important; 
            color: white !important; 
            border-color: var(--color-flash-blue) !important;
        }

        /* 21. Countdown Text Size - Sizing Fix Implemented Here */
        #countdown-text {
            font-size: 3rem; 
            min-width: 500px; 
            display: inline-block;
            transition: none; 
        }
        
        /* 9. Main Application Layout */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-light);
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Status Bar -->
    <header class="h-16 flex items-center justify-between px-6 z-10 bg-white border-b border-gray-200 shadow-md relative">
        <div id="last-rt-display" class="text-sm font-semibold text-gray-600">
            Last RT: -- ms
        </div>

        <!-- Center Status -->
        <div id="status-display" class="text-lg font-bold text-gray-800 absolute left-1/2 transform -translate-x-1/2">
            Ready
        </div>

        <!-- Pause/Resume Button -->
        <button id="btn-pause-resume" 
                class="w-10 h-10 text-2xl bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 transition duration-150 shadow-inner disabled:opacity-50"
                disabled
                title="Pause/Resume Game">
            ⏸
        </button>
    </header>

    <!-- Options Bar -->
    <nav id="options-bar" class="p-3 bg-gray-50 border-b border-gray-200">
        <!-- Button Layout -->
        <div class="flex gap-3 flex-wrap justify-center">
            
            <!-- Training & Test Buttons -->
            <button id="btn-fixed-practice" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Training Set A
            </button>
            <button id="btn-variable-practice" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Training Set B
            </button>
            <button id="btn-test-variable" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Reaction Test 1
            </button>
            <button id="btn-test-fixed" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Reaction Test 2
            </button>
            <button id="btn-results" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                View Historical Results
            </button>
        </div>
    </nav>

    <!-- Reaction Area Container -->
    <main id="reaction-area-container" class="flex-1 flex items-center justify-center p-4">
        <!-- Reaction Box -->
        <div id="reaction-box" class="flex items-center justify-center text-center p-8" onclick="window.handleReaction(event)">
            <!-- Initial Content Text -->
            <span id="countdown-text">Welcome</span>
        </div>
    </main>

    <!-- Results Modal (Hidden) - Updated to a Single View -->
    <div id="results-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
        <!-- Main Content Panel (Full Width and Height) -->
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-800">
                All Historical Session Results
            </h2>
            
            <!-- Export Status Display (USED FOR APPS SCRIPT FEEDBACK) -->
            <div id="export-status" class="hidden p-3 mb-4 text-sm font-semibold rounded-lg"></div>

            <!-- Main Content Area -->
            <div id="session-details-content" class="text-sm flex-1 overflow-y-auto">
                
                <!-- Summary Area (Always Visible: Totals for ALL sessions) -->
                <div id="summary-area" class="mb-4 space-y-1 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <p class="text-xs text-gray-500">Totals calculated from all sessions below.</p>
                    <p>Participant: <span id="participant-name" class="font-medium">--</span></p>
                    <p>Total Sessions: <span id="results-total-sessions" class="font-medium">--</span></p>
                    <p>Total Rounds: <span id="results-total-rounds" class="font-medium">--</span></p>
                    <p class="mt-2 text-base font-semibold">
                        Overall Average RT: <span id="results-avg-rt" class="text-green-600">--</span> ms | 
                        Total Hits: <span id="results-hits" class="text-green-600">--</span> | 
                        Total False Starts: <span id="results-false-starts" class="text-red-600">--</span> | 
                        Total Missed: <span id="results-missed" class="text-yellow-600">--</span>
                    </p>
                </div>
                
                <h3 class="text-lg font-semibold mt-6 mb-2">Unified Round Breakdown (Ordered by Experiment Phase)</h3>
                <div id="results-loading-message" class="text-center p-8 text-gray-500">Loading results...</div>

                <div class="overflow-x-auto">
                    <table id="results-table" class="min-w-full divide-y divide-gray-200 mb-6 hidden">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Round</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Reaction Time (ms)</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200" id="results-table-body">
                            <!-- Details loaded here sequentially -->
                        </tbody>
                    </table>
                </div>
                
            </div>
            <!-- Close Button -->
            <div class="mt-auto pt-4 border-t flex justify-end">
                <button onclick="document.getElementById('results-modal').classList.add('hidden')" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-lg transition duration-200">Close</button>
            </div>
        </div>
    </div>

    <!-- Initial State: Participant Information Modal -->
    <div id="info-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md">
            <!-- Info Modal Title -->
            <h2 class="text-2xl font-bold mb-6">Participant Information</h2>
            <form id="participant-form">
                <div class="mb-4">
                    <!-- Info Modal Name Label -->
                    <label for="full-name" class="block text-sm font-medium text-gray-700 mb-1">Full Name</label>
                    <input type="text" id="full-name" name="fullName" required class="mt-1 block w-full border border-gray-300 rounded-lg shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                    <div id="name-error" class="text-red-500 text-xs mt-1 hidden" role="alert"></div>
                </div>
                <div class="mb-4">
                    <!-- Info Modal Grade Label -->
                    <label for="grade-level" class="block text-sm font-medium text-gray-700 mb-1">Grade Level (Number Only, 1-12)</label>
                    <input type="number" id="grade-level" name="gradeLevel" min="1" max="12" required class="mt-1 block w-full border border-gray-300 rounded-lg shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="mb-6">
                    <span class="block text-sm font-medium text-gray-700 mb-2">Sex</span>
                    <!-- Info Modal Sex Options -->
                    <div class="flex space-x-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="sex" value="Male" required class="form-radio h-4 w-4 text-blue-600">
                            <span class="ml-2 text-gray-700">Male</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="sex" value="Female" required class="form-radio h-4 w-4 text-blue-600">
                            <span class="ml-2 text-gray-700">Female</span>
                        </label>
                    </div>
                </div>
                <!-- Info Modal Button -->
                <button id="btn-start-experiment" type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-lg">
                    Start Experiment
                </button>
            </form>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, collection, query, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Variables (Mandatory) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Game Setup ---
        let app, db, auth, userId = null;

        // NOTE: --- THE APPS SCRIPT WEB APP URL MUST GO HERE (Step 5) ---
        // Replace this empty string with the URL you get after deployment.
        const GAS_WEB_APP_URL = "https://script.google.com/a/macros/mycw.org/s/AKfycbyYV_kRfMGX6J1KTkKWcw9c-6kvgaa_o7XTfcnBcVd9edj8k8Ts0dA1hD7yVM50mySpbQ/exec"; 
        
        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing or empty. Data will not persist across sessions.");
                    return;
                }
                
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase authenticated. User ID:", userId);
                    } else {
                        userId = crypto.randomUUID(); 
                        console.warn("User not authenticated. Using random UUID for user ID.");
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase or signing in:", error);
                userId = crypto.randomUUID(); // Fallback
            }
        }
        
        /**
         * Saves the current session's results to Firestore (for historical viewing).
         */
        window.saveResults = async function(mode, totalRounds, results) {
            if (!db || !userId) {
                console.error("Database not initialized or User ID not set. Cannot save.");
                return;
            }

            const dataToSave = {
                appId: appId,
                userId: userId,
                participant: window.gameState.participant, // Save participant info with results
                mode: mode,
                totalRounds: totalRounds,
                timestamp: serverTimestamp(),
                results: results
            };

            const path = `/artifacts/${appId}/users/${userId}/results`;
            let docRef;
            try {
                docRef = await addDoc(collection(db, path), dataToSave);
                console.log("Session results saved successfully to Firestore.");
            } catch (e) {
                console.error("Error adding document to Firestore: ", e);
                return;
            }
            
            // --- CRITICAL STEP: Send the same data to Google Apps Script ---
            // We pass the document ID back to the server, so you can track it if needed.
            window.sendToAppsScript({
                docId: docRef.id,
                ...dataToSave,
                // Ensure timestamp is sent as a readable string since it's now a Firestore object
                timestamp: new Date().toISOString() 
            });
        };
        
        /**
         * Sends the collected data to the Google Apps Script Web App for Sheet logging.
         */
        window.sendToAppsScript = async function(data) {
            const status = document.getElementById('export-status');
            
            if (!GAS_WEB_APP_URL || GAS_WEB_APP_URL === "") {
                console.error("GAS_WEB_APP_URL is not set. Data not sent to Google Sheet.");
                status.textContent = 'ERROR: Apps Script URL not set. Data NOT saved to Google Sheet.';
                status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-red-100 text-red-700';
                status.classList.remove('hidden');
                return;
            }

            status.textContent = 'Saving data to Google Sheet...';
            status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-blue-100 text-blue-700';
            status.classList.remove('hidden');

            try {
                const response = await fetch(GAS_WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors', // Required for simple post to Apps Script
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                // Note: The 'no-cors' mode means we can't inspect the response content, 
                // but if the fetch is successful, we assume the server received it.
                if (response) {
                    status.textContent = 'Data successfully sent to Google Sheet.';
                    status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-green-100 text-green-700';
                }
                
            } catch (error) {
                console.error("Error sending data to Apps Script:", error);
                status.textContent = `CRITICAL ERROR: Failed to send data to Google Sheet. Details in console.`;
                status.className = 'p-3 mb-4 text-sm font-semibold rounded-lg bg-red-100 text-red-700';
            }
            
            // Hide status after a few seconds
            setTimeout(() => status.classList.add('hidden'), 5000);
        };


        // Helper and display functions (formatMode, showAllHistoricalResults) remain the same...

        function formatMode(mode) {
            switch (mode) {
                case 'fixed-practice': return 'Training Set A (Fixed)';
                case 'variable-practice': return 'Training Set B (Variable)';
                case 'variable-test': return 'Reaction Test 1 (Variable Cue)';
                case 'fixed-test': return 'Reaction Test 2 (Fixed Cue)';
                default: return mode;
            }
        }
        
        /**
         * Fetches and displays all historical results from Firestore.
         * FIX: Ensures the modal is shown immediately and provides clear feedback 
         * if the database is not ready yet.
         */
        window.showAllHistoricalResults = async function() {
            const loadingMessage = document.getElementById('results-loading-message');
            const resultsTable = document.getElementById('results-table');
            const resultsTableBody = document.getElementById('results-table-body');
            const exportStatus = document.getElementById('export-status');
            
            // CRITICAL FIX: Show modal immediately so the user knows the button press registered
            document.getElementById('results-modal').classList.remove('hidden');

            if (!db || !userId) {
                console.error("Database not initialized or User ID not set. Cannot view results.");
                loadingMessage.textContent = 'Error: Database connection not ready. Please wait a moment and try again.';
                loadingMessage.classList.remove('hidden');
                resultsTable.classList.add('hidden');
                return;
            }
            
            // Set initial state for loading
            loadingMessage.textContent = 'Loading results...';
            loadingMessage.classList.remove('hidden');
            resultsTable.classList.add('hidden');
            resultsTableBody.innerHTML = '';
            exportStatus.classList.add('hidden'); // Clear status


            const path = `/artifacts/${appId}/users/${userId}/results`;
            
            try {
                const q = query(collection(db, path));
                const querySnapshot = await getDocs(q);
                
                if (querySnapshot.empty) {
                    loadingMessage.textContent = 'No past sessions found.';
                    return; // Modal is already visible
                }

                const modeOrder = {
                    'fixed-practice': 1,
                    'variable-practice': 1,
                    'variable-test': 2,
                    'fixed-test': 3
                };

                let allSessions = [];
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const timestampMs = data.timestamp ? (data.timestamp.toMillis ? data.timestamp.toMillis() : 0) : 0;
                    allSessions.push({ id: doc.id, ...data, timestampMs });
                });

                allSessions.sort((a, b) => {
                    const orderA = modeOrder[a.mode] || 99;
                    const orderB = modeOrder[b.mode] || 99;
                    
                    if (orderA !== orderB) {
                        return orderA - orderB;
                    }
                    return a.timestampMs - b.timestampMs;
                });

                let totalHits = 0;
                let totalFalseStarts = 0;
                let totalMissed = 0;
                let totalRounds = 0;
                let allRts = [];
                let participantName = allSessions[0].participant?.fullName || 'N/A';
                
                allSessions.forEach(session => {
                    session.results.forEach(result => {
                        if (result.status === 'HIT' && result.rt !== null) {
                            allRts.push(result.rt);
                        }
                    });
                    totalRounds += session.totalRounds;
                    totalHits += session.results.filter(r => r.status === 'HIT').length;
                    totalFalseStarts += session.results.filter(r => r.status === 'FALSE START').length;
                    totalMissed += session.results.filter(r => r.status === 'MISSED').length;
                });
                
                const overallAvgRt = allRts.length > 0 ? (allRts.reduce((a, b) => a + b, 0) / allRts.length).toFixed(0) : '--';

                // --- 2. Update Summary Area ---
                document.getElementById('participant-name').textContent = participantName; 
                document.getElementById('results-total-sessions').textContent = allSessions.length;
                document.getElementById('results-total-rounds').textContent = totalRounds;
                document.getElementById('results-avg-rt').textContent = overallAvgRt;
                document.getElementById('results-hits').textContent = totalHits;
                document.getElementById('results-false-starts').textContent = totalFalseStarts;
                document.getElementById('results-missed').textContent = totalMissed;

                // --- 3. Populate Unified Breakdown Table ---
                allSessions.forEach((session, sessionIndex) => {
                    const displayMode = formatMode(session.mode);
                    
                    const sessionHits = session.results.filter(r => r.status === 'HIT');
                    const sessionAvgRt = sessionHits.length > 0 ? (sessionHits.map(r => r.rt).reduce((a, b) => a + b, 0) / sessionHits.length).toFixed(0) : '--';
                    
                    const headerRow = resultsTableBody.insertRow();
                    headerRow.className = 'text-sm bg-blue-100 font-bold border-t-4 border-blue-400';
                    headerRow.innerHTML = `
                        <td class="px-3 py-2 whitespace-nowrap" colspan="4">
                            ${displayMode} (Session Avg RT: ${sessionAvgRt} ms)
                        </td>
                    `;

                    session.results.forEach((result, index) => {
                        const row = resultsTableBody.insertRow();
                        row.className = 'text-sm ' + (index % 2 === 0 ? 'bg-white' : 'bg-gray-50'); 
                        
                        const rtDisplay = result.rt !== null ? result.rt.toFixed(0) : '--';
                        let statusClass = 'text-gray-500';
                        if (result.status === 'HIT') statusClass = 'text-green-600 font-bold';
                        else if (result.status === 'FALSE START') statusClass = 'text-red-600 font-bold';

                        row.innerHTML = `
                            <td class="px-3 py-2 whitespace-nowrap">${displayMode}</td>
                            <td class="px-3 py-2 whitespace-nowrap">${result.round}</td>
                            <td class="px-3 py-2 whitespace-nowrap">${rtDisplay}</td>
                            <td class="px-3 py-2 whitespace-nowrap">
                                <span class="${statusClass}">${result.status}</span>
                            </td>
                        `;
                    });
                    
                    const falseStartCount = session.results.filter(r => r.status === 'FALSE START').length;
                    const summaryRow = resultsTableBody.insertRow();
                    summaryRow.className = 'text-base bg-yellow-100 font-semibold border-b-2 border-yellow-400'; 
                    summaryRow.innerHTML = `
                        <td class="px-3 py-2 whitespace-nowrap" colspan="3">Total False Starts for ${displayMode}:</td>
                        <td class="px-3 py-2 whitespace-nowrap text-red-600">${falseStartCount}</td>
                    `;
                });
                
                loadingMessage.classList.add('hidden');
                resultsTable.classList.remove('hidden');


            } catch (error) {
                console.error("Error fetching results: ", error);
                loadingMessage.textContent = 'Error loading data. Check console for details.';
            }
        };


        // Initialize Firebase on load
        window.addEventListener('load', initFirebase);
    </script>

    <script>
        // --- 3.A. Game Constants ---
        const FIXED_INTERVAL_MS = 3500; 
        const PRACTICE_ROUNDS = 30; 
        const SINGLE_ROUND = 1; 
        const MISSED_TIMEOUT_MS = 10000; 
        const POST_TRIAL_DELAY_MS = 1500; 
        
        // --- 3.B. Variable Intervals (Mandatory Array) ---
        const VARIABLE_INTERVALS_MS = [
            1840, 2190, 3970, 5320, 2780, 4260, 1370, 3440, 2550, 5750,
            3690, 1220, 4580, 5010, 2070, 3120, 4970, 1660, 2900, 3830,
            2680, 4330, 2450, 5190, 1080, 3570, 2360, 4810, 5440, 1930
        ];

        // --- DOM Elements ---
        const infoModal = document.getElementById('info-modal');
        const participantForm = document.getElementById('participant-form');
        const reactionBox = document.getElementById('reaction-box');
        const countdownText = document.getElementById('countdown-text');
        const statusDisplay = document.getElementById('status-display');
        const lastRtDisplay = document.getElementById('last-rt-display');
        const btnPauseResume = document.getElementById('btn-pause-resume');
        const btnFixedPractice = document.getElementById('btn-fixed-practice');
        const btnVariablePractice = document.getElementById('btn-variable-practice');
        const btnTestVariable = document.getElementById('btn-test-variable');
        const btnTestFixed = document.getElementById('btn-test-fixed');
        const btnResults = document.getElementById('btn-results');
        const fullNameInput = document.getElementById('full-name');
        const nameErrorDisplay = document.getElementById('name-error');

        // --- Game State (Updated with sequential flags) ---
        window.gameState = {
            participant: null, 
            mode: 'none', 
            isRunning: false,
            isPaused: false,
            isWaitingForCue: false,
            isWaitingForReaction: false,
            
            hasStartedFixedPractice: false,
            hasStartedVariablePractice: false,
            hasCompletedTraining: false, 
            hasCompletedTest1: false, 
            isSessionComplete: false, 
            
            currentRound: 0,
            totalRounds: 0,
            intervalArray: [], 
            intervalIndex: 0,
            timers: {
                countdown: null,
                cue: null,
                timeout: null,
                delay: null
            },
            startTime: 0, 
            cueTime: 0, 
            results: []
        };
        let gameState = window.gameState; 

        // --- Utility Functions ---
        
        function randomizeArray(array) {
            let currentIndex = array.length, randomIndex;
            let arr = [...array]; // Create a copy
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [arr[currentIndex], arr[randomIndex]] = [
                    arr[currentIndex], arr[randomIndex]
                ];
            }
            return arr;
        }

        function updateStatus(text, color = 'text-gray-800') {
            statusDisplay.textContent = text;
            statusDisplay.className = `text-lg font-bold absolute left-1/2 transform -translate-x-1/2 ${color}`;
        }
        
        function clearAllTimers() {
            Object.values(gameState.timers).forEach(timer => {
                if (timer) clearTimeout(timer);
                if (timer) clearInterval(timer);
            });
            gameState.timers = { countdown: null, cue: null, timeout: null, delay: null };
        }

        // --- UI State Management ---

        function updateModeButtons() {
            const disableAllModes = gameState.isRunning || gameState.isPaused;

            const hasStartedAnyTraining = gameState.hasStartedFixedPractice || gameState.hasStartedVariablePractice;
            
            btnFixedPractice.disabled = disableAllModes || hasStartedAnyTraining;
            btnVariablePractice.disabled = disableAllModes || hasStartedAnyTraining;
            
            btnTestVariable.disabled = disableAllModes || !gameState.hasCompletedTraining || gameState.hasCompletedTest1;
            
            btnTestFixed.disabled = disableAllModes || !gameState.hasCompletedTest1;

            btnPauseResume.disabled = !gameState.isRunning;
            if (gameState.isPaused) {
                btnPauseResume.textContent = '▶'; 
            } else {
                btnPauseResume.textContent = '⏸'; 
            }
        }

        function togglePause() {
            if (!gameState.isRunning) return;

            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                clearAllTimers();
                reactionBox.classList.remove('flash-cue'); 
                countdownText.textContent = 'Paused';
                updateStatus('Paused', 'text-orange-500');
            } else {
                updateStatus(`Resumed. Restarting Round ${gameState.currentRound}...`, 'text-green-500');
                gameState.timers.delay = setTimeout(restartCurrentRound, 500); 
            }
            updateModeButtons();
        }

        function restartCurrentRound() {
            if (gameState.isPaused || !gameState.isRunning) return;
            startCountdown();
        }

        function cueFlash() {
            gameState.cueTime = Date.now();
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = true;
            
            reactionBox.classList.add('flash-cue');
            countdownText.textContent = ''; 
            updateStatus('REACT NOW!', 'text-blue-500');

            gameState.timers.timeout = setTimeout(handleTimeout, MISSED_TIMEOUT_MS);
        }

        function startCountdown() {
            if (gameState.isPaused || !gameState.isRunning) return;

            let count = 3;
            reactionBox.classList.remove('flash-cue', 'bg-red-400', 'text-white');
            countdownText.textContent = count;
            updateStatus(`Round ${gameState.currentRound}/${gameState.totalRounds}. Get Ready...`);
            
            if (gameState.timers.countdown) clearInterval(gameState.timers.countdown);

            gameState.timers.countdown = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else {
                    clearInterval(gameState.timers.countdown);
                    countdownText.textContent = ''; 
                    updateStatus('WAIT for the flash', 'text-gray-700');
                    startRoundTimer();
                }
            }, 1000);
        }

        function nextRound() {
            if (gameState.isPaused || !gameState.isRunning || gameState.isSessionComplete) return;

            gameState.currentRound++; 
            
            if (gameState.currentRound > gameState.totalRounds) {
                endSession();
                return;
            }
            
            if (gameState.mode === 'variable-practice') {
                gameState.intervalIndex++;
            }
            
            startCountdown();
        }

        function endSession() {
            clearAllTimers();
            gameState.isRunning = false;
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = false;
            gameState.isSessionComplete = true; 

            // --- CRITICAL STEP: Save results and trigger Apps Script send ---
            window.saveResults(gameState.mode, gameState.totalRounds, gameState.results);

            let message = '';
            let statusColor = '';
            
            if (gameState.mode === 'fixed-practice' || gameState.mode === 'variable-practice') { 
                gameState.hasCompletedTraining = true;
                message = 'Training Complete!';
                statusColor = 'text-green-700';
            } else if (gameState.mode === 'variable-test') {
                gameState.hasCompletedTest1 = true;
                message = 'Test 1 Complete!';
                statusColor = 'text-green-700';
            } else if (gameState.mode === 'fixed-test') {
                message = 'All Tests Complete!';
                statusColor = 'text-blue-700';
            }

            countdownText.textContent = message;
            updateStatus(message, statusColor);
            updateModeButtons();
        }

        function handleHit() {
            clearTimeout(gameState.timers.timeout); 

            const reactionTime = Date.now() - gameState.cueTime;
            const interval = gameState.cueTime - gameState.startTime;

            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: interval,
                rt: reactionTime,
                status: 'HIT'
            });

            reactionBox.classList.remove('flash-cue');
            countdownText.textContent = `${reactionTime.toFixed(0)} ms`;
            lastRtDisplay.textContent = `Last RT: ${reactionTime.toFixed(0)} ms`;
            updateStatus('HIT!', 'text-green-600');
            
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(nextRound, POST_TRIAL_DELAY_MS);
        }

        function handleFalseStart() {
            clearAllTimers();
            
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: null,
                rt: null,
                status: 'FALSE START'
            });

            countdownText.textContent = 'FALSE START';
            reactionBox.classList.add('bg-red-400', 'text-white');
            reactionBox.classList.remove('flash-cue');
            updateStatus('FALSE START! Restarting round...', 'text-red-600');
            
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(() => {
                restartCurrentRound(); 
            }, 500); 
        }
        
        function handleTimeout() {
            clearAllTimers();
            
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: gameState.cueTime - gameState.startTime,
                rt: null,
                status: 'MISSED'
            });

            countdownText.textContent = 'MISSED';
            reactionBox.classList.remove('flash-cue');
            updateStatus('MISSED! Starting next round...', 'text-yellow-600');
            
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(nextRound, POST_TRIAL_DELAY_MS);
        }

        function startRoundTimer() {
            gameState.isWaitingForCue = true;
            gameState.startTime = Date.now();

            let interval;
            
            if (gameState.mode === 'variable-test') {
                 interval = 2360; 
            } 
            else if (gameState.mode === 'fixed-practice' || gameState.mode === 'fixed-test') {
                interval = FIXED_INTERVAL_MS; 
            } 
            else if (gameState.mode === 'variable-practice') {
                interval = gameState.intervalArray[gameState.intervalIndex];
            } else {
                console.error("Unknown game mode:", gameState.mode);
                interval = FIXED_INTERVAL_MS;
            }

            gameState.timers.cue = setTimeout(cueFlash, interval);
        }

        function startSession(mode, totalRounds) {
            if (gameState.isSessionComplete && gameState.isRunning) return; 

            clearAllTimers();

            if (mode === 'fixed-practice') gameState.hasStartedFixedPractice = true;
            if (mode === 'variable-practice') gameState.hasStartedVariablePractice = true;
            
            gameState.mode = mode;
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.isSessionComplete = false; 
            gameState.currentRound = 0; 
            gameState.totalRounds = totalRounds;
            gameState.results = [];
            
            if (mode === 'variable-practice') {
                gameState.intervalArray = randomizeArray(VARIABLE_INTERVALS_MS);
                gameState.intervalIndex = 0;
            } else {
                gameState.intervalArray = [];
                gameState.intervalIndex = 0;
            }

            btnPauseResume.disabled = false;
            updateModeButtons();
            
            nextRound(); 
        }

        window.handleReaction = function(event) {
            if (gameState.isPaused || !gameState.isRunning || gameState.isSessionComplete) return;

            if (gameState.isWaitingForReaction) {
                handleHit();
            } else if (gameState.isWaitingForCue) {
                handleFalseStart();
            } else {
                console.log("Reaction ignored. Not cue or reaction phase.");
            }
        }


        // --- Event Listeners and Initialization ---

        participantForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            
            const fullName = formData.get('fullName').trim();
            const gradeLevel = parseInt(formData.get('gradeLevel'));
            
            nameErrorDisplay.classList.add('hidden'); 

            const nameRegex = /^[A-Za-z\s.'-]+$/; 
            
            if (fullName.length < 2) {
                nameErrorDisplay.textContent = "Please enter your full name (at least two characters).";
                nameErrorDisplay.classList.remove('hidden');
                return; 
            }
            
            if (!nameRegex.test(fullName)) {
                nameErrorDisplay.textContent = "Name contains invalid characters. Use only letters, spaces, hyphens, apostrophes, or periods.";
                nameErrorDisplay.classList.remove('hidden');
                return; 
            }
            
            if (gradeLevel < 1 || gradeLevel > 12) {
                console.error("Grade level out of range.");
                return; 
            }
            
            gameState.participant = {
                fullName: fullName,
                gradeLevel: gradeLevel,
                sex: formData.get('sex')
            };

            infoModal.classList.add('hidden');
            countdownText.textContent = 'Welcome';
            updateStatus('Ready. Choose a Training Set.');
            updateModeButtons(); 
        });

        document.querySelectorAll('.btn-mode').forEach(button => {
            button.addEventListener('click', (e) => {
                if (e.target.disabled) return; 

                const id = e.target.id;
                let mode, rounds;

                if (id === 'btn-fixed-practice') { 
                    mode = 'fixed-practice';
                    rounds = PRACTICE_ROUNDS;
                } else if (id === 'btn-variable-practice') { 
                    mode = 'variable-practice';
                    rounds = PRACTICE_ROUNDS;
                } else if (id === 'btn-test-variable') { 
                    mode = 'variable-test';
                    rounds = SINGLE_ROUND; 
                } else if (id === 'btn-test-fixed') { 
                    mode = 'fixed-test';
                    rounds = SINGLE_ROUND; 
                } else { 
                    return;
                }

                if (gameState.participant) {
                    startSession(mode, rounds);
                } else {
                    countdownText.textContent = "Please provide participant info first.";
                    updateStatus('Start Experiment Required', 'text-red-500');
                    infoModal.classList.remove('hidden');
                }
            });
        });

        btnPauseResume.addEventListener('click', togglePause);

        btnResults.addEventListener('click', () => {
            window.showAllHistoricalResults();
        });

        reactionBox.addEventListener('click', window.handleReaction);

        document.onkeydown = function(e) {
            if (e.key === ' ' || e.key === 'Spacebar') {
                
                // Check if the user is typing in an input field. If so, let them type a space.
                const activeTag = document.activeElement.tagName;
                const activeType = document.activeElement.type;
                const isTyping = (activeTag === 'INPUT' || activeTag === 'TEXTAREA') && 
                                 (activeType === 'text' || activeType === 'number');

                if (isTyping) {
                    return; 
                }

                e.preventDefault(); 

                // 1. If paused, spacebar resumes (addresses user request)
                if (gameState.isRunning && gameState.isPaused) {
                    togglePause();
                    return;
                }
                
                // 2. If running (or waiting for a cue), spacebar acts as reaction
                if (gameState.isRunning) {
                    window.handleReaction(e);
                    return;
                }
            }
        };

        window.addEventListener('blur', () => {
            if (gameState.isRunning && !gameState.isPaused) {
                togglePause(); 
            }
        });
        
        updateStatus('Ready');
        updateModeButtons();
    </script>
</body>
</html>

