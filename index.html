/**
 * Handles POST requests from the web page to receive experiment data.
 * Updated to include participant demographic fields (Full Name, Grade, Sex).
 * @param {object} e The event parameter containing data from the POST request.
 */
function doPost(e) {
  // Check if there is data in the POST body
  if (!e || !e.postData || !e.postData.contents) {
    return ContentService.createTextOutput("Error: No data received.").setMimeType(ContentService.MimeType.TEXT);
  }

  try {
    // 1. Parse the JSON payload sent from the HTML application
    const payload = JSON.parse(e.postData.contents);
    const metadata = payload.metadata;
    const data = payload.data;

    // 2. Get the active spreadsheet and the first sheet (Sheet1)
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName("Sheet1") || ss.getSheets()[0]; 

    // 3. Define the headers for consistency (must match your Sheet headers)
    const headers = [
      'Timestamp', 'Session ID', 'Mode Name', 'Full Name', 'Grade', 'Sex', 
      'Round', 'Interval (ms)', 'RT (ms)', 'Success', 'False Start', 'User Agent'
    ];

    // Check if headers need to be written (only if the sheet is empty)
    if (sheet.getLastRow() === 0) {
      sheet.appendRow(headers);
    }
    
    // 4. Iterate through the trial data and append rows
    let rowsAdded = 0;
    data.forEach(trial => {
      const row = [
        // Metadata fields (repeated for every trial in the block)
        trial.timestamp,
        metadata.session_id,
        metadata.mode_name,
        metadata.full_name, // NEW
        metadata.grade,      // NEW
        metadata.sex,        // NEW
        
        // Trial-specific fields
        trial.round,
        trial.interval_ms,
        trial.rt_ms,
        trial.success,
        trial.is_false_start,
        metadata.user_agent
      ];
      sheet.appendRow(row);
      rowsAdded++;
    });

    // 5. Return success response
    return ContentService.createTextOutput(`Success: ${rowsAdded} rows logged.`).setMimeType(ContentService.MimeType.TEXT);

  } catch (error) {
    // Return error response
    return ContentService.createTextOutput("Error: " + error.toString() + " | Input: " + e.postData.contents).setMimeType(ContentService.MimeType.TEXT);
  }
}


