<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anticipation vs. Reaction Time Training</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 2.A. Color Variables */
        :root {
            --color-bg-light: #f3f4f6; /* gray-100 */
            --color-bg-mid: #e5e7eb; /* gray-200 */
            --color-text-dark: #1f2937; /* gray-800 */
            --color-flash-blue: #3b82f6; /* blue-500 */
            --color-border: #9ca3af; /* gray-400 */
        }

        /* 2.B. Reaction Box and Text Styling */
        #reaction-box {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 80vh; 
            background-color: var(--color-bg-mid);
            border: 4px solid var(--color-border);
            border-radius: 1rem;
            box-shadow: 0 10px 15px 3px rgba(0, 0, 0, 0.1), 0 4px 6px 2px rgba(0, 0, 0, 0.05);
            font-size: 3rem;
            font-weight: 800;
            color: var(--color-text-dark);
            cursor: pointer;
            user-select: none;
            transition: all 0.1s ease;
        }

        /* 2.C. Blue Cue State (.flash-cue) */
        .flash-cue {
            background-color: var(--color-flash-blue) !important; 
            color: white !important; 
            border-color: var(--color-flash-blue) !important;
        }

        /* 21. Countdown Text Size */
        #countdown-text {
            font-size: 3rem; 
            min-width: 500px; 
            display: inline-block;
            transition: none; 
        }
        
        /* 9. Main Application Layout */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-light);
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Status Bar -->
    <header class="h-16 flex items-center justify-between px-6 z-10 bg-white border-b border-gray-200 shadow-md relative">
        <div id="last-rt-display" class="text-sm font-semibold text-gray-600">
            Last RT: -- ms
        </div>

        <!-- Center Status -->
        <div id="status-display" class="text-lg font-bold text-gray-800 absolute left-1/2 transform -translate-x-1/2">
            Ready
        </div>

        <!-- Pause/Resume Button -->
        <button id="btn-pause-resume" 
                class="w-10 h-10 text-2xl bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 transition duration-150 shadow-inner disabled:opacity-50"
                disabled
                title="Pause/Resume Game">
            ⏸
        </button>
    </header>

    <!-- Options Bar -->
    <nav id="options-bar" class="p-3 bg-gray-50 border-b border-gray-200">
        <!-- Button Layout -->
        <div class="flex gap-3 flex-wrap justify-center">
            
            <!-- Training & Test Buttons -->
            <button id="btn-fixed-practice" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Training Set A
            </button>
            <button id="btn-variable-practice" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Training Set B
            </button>
            <button id="btn-test-variable" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Reaction Test 1
            </button>
            <button id="btn-test-fixed" class="btn-mode bg-gray-700 hover:bg-gray-800 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Reaction Test 2
            </button>
            <!-- RESULTS BUTTON - Now enabled by default and renamed -->
            <button id="btn-results" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                View Results
            </button>
        </div>
    </nav>

    <!-- Reaction Area Container -->
    <main id="reaction-area-container" class="flex-1 flex items-center justify-center p-4">
        <!-- Reaction Box -->
        <div id="reaction-box" class="flex items-center justify-center text-center p-8" onclick="window.handleReaction(event)">
            <!-- Initial Content Text -->
            <span id="countdown-text">Welcome</span>
        </div>
    </main>

    <!-- Results Modal (Hidden) -->
    <div id="results-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center p-4">
        <!-- Main Content Panel -->
        <div class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
            
            <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-800">
                All Historical Session Results
            </h2>
            
            <!-- Main Content Area -->
            <div id="session-details-content" class="text-sm flex-1 overflow-y-auto">
                
                <!-- Summary Area (Always Visible: Totals for ALL sessions) -->
                <div id="summary-area" class="mb-4 space-y-1 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <p class="text-xs text-gray-500">Totals calculated from all sessions below.</p>
                    <p>Participant: <span id="participant-name" class="font-medium">--</span></p>
                    <p>Total Sessions: <span id="results-total-sessions" class="font-medium">--</span></p>
                    <p>Total Rounds: <span id="results-total-rounds" class="font-medium">--</span></p>
                    <p class="mt-2 text-base font-semibold">
                        Overall Average RT: <span id="results-avg-rt" class="text-green-600">--</span> ms | 
                        Total Hits: <span id="results-hits" class="text-green-600">--</span> | 
                        Total False Starts: <span id="results-false-starts" class="text-red-600">--</span> | 
                        Total Missed: <span id="results-missed" class="text-yellow-600">--</span>
                    </p>
                </div>
                
                <h3 class="text-lg font-semibold mt-6 mb-2">Unified Round Breakdown (Ordered by Experiment Phase)</h3>
                <div id="results-loading-message" class="text-center p-8 text-gray-500">Loading results...</div>

                <div class="overflow-x-auto">
                    <table id="results-table" class="min-w-full divide-y divide-gray-200 mb-6 hidden">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Round</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Reaction Time (ms)</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200" id="results-table-body">
                            <!-- Details loaded here sequentially -->
                        </tbody>
                    </table>
                </div>
                
            </div>
            <!-- Modal Footer with Download and Close Buttons -->
            <div class="mt-auto pt-4 border-t flex justify-between items-center">
                <!-- Download Button -->
                <button id="btn-download-csv" onclick="window.downloadCSV()" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition duration-200 disabled:opacity-50" disabled>
                    Download as CSV
                </button>
                <!-- Close Button -->
                <button onclick="document.getElementById('results-modal').classList.add('hidden')" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-lg transition duration-200">Close</button>
            </div>
        </div>
    </div>

    <!-- Initial State: Participant Information Modal -->
    <div id="info-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md">
            <!-- Info Modal Title -->
            <h2 class="text-2xl font-bold mb-6">Participant Information</h2>
            <form id="participant-form">
                <div class="mb-4">
                    <!-- Info Modal Name Label -->
                    <label for="full-name" class="block text-sm font-medium text-gray-700 mb-1">Full Name</label>
                    <input type="text" id="full-name" name="fullName" required class="mt-1 block w-full border border-gray-300 rounded-lg shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                    <div id="name-error" class="text-red-500 text-xs mt-1 hidden" role="alert"></div>
                </div>
                <div class="mb-4">
                    <!-- Info Modal Grade Label -->
                    <label for="grade-level" class="block text-sm font-medium text-gray-700 mb-1">Grade Level (Number Only, 1-12)</label>
                    <input type="number" id="grade-level" name="gradeLevel" min="1" max="12" required class="mt-1 block w-full border border-gray-300 rounded-lg shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="mb-6">
                    <span class="block text-sm font-medium text-gray-700 mb-2">Sex</span>
                    <!-- Info Modal Sex Options -->
                    <div class="flex space-x-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="sex" value="Male" required class="form-radio h-4 w-4 text-blue-600">
                            <span class="ml-2 text-gray-700">Male</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="sex" value="Female" required class="form-radio h-4 w-4 text-blue-600">
                            <span class="ml-2 text-gray-700">Female</span>
                        </label>
                    </div>
                </div>
                <!-- Info Modal Button -->
                <button id="btn-start-experiment" type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-lg">
                    Start Experiment
                </button>
            </form>
        </div>
    </div>

    <script>
        // --- LOCAL STORAGE FUNCTIONS ---
        // New utility functions for local data persistence
        
        /**
         * Safely loads all session data from localStorage.
         * @returns {Array} An array of stored session objects.
         */
        function loadLocalResults() {
            const json = localStorage.getItem('reactionTrainerSessions');
            try {
                return json ? JSON.parse(json) : [];
            } catch (e) {
                console.error("Error parsing local results, resetting storage.", e);
                return [];
            }
        }

        /**
         * Appends a new session's results to the local storage.
         * @param {Object} sessionData - The complete session object to save.
         */
        function saveLocalSession(sessionData) {
            const sessions = loadLocalResults();
            sessions.push(sessionData);
            localStorage.setItem('reactionTrainerSessions', JSON.stringify(sessions));
        }

        // --- 3.A. Game Constants ---
        const FIXED_INTERVAL_MS = 3500; 
        const PRACTICE_ROUNDS = 30; 
        const SINGLE_ROUND = 1; 
        const MISSED_TIMEOUT_MS = 10000; 
        const POST_TRIAL_DELAY_MS = 1500; 
        
        // --- 3.B. Variable Intervals (Mandatory Array) ---
        const VARIABLE_INTERVALS_MS = [
            1840, 2190, 3970, 5320, 2780, 4260, 1370, 3440, 2550, 5750,
            3690, 1220, 4580, 5010, 2070, 3120, 4970, 1660, 2900, 3830,
            2680, 4330, 2450, 5190, 1080, 3570, 2360, 4810, 5440, 1930
        ];

        // --- DOM Elements ---
        const infoModal = document.getElementById('info-modal');
        const participantForm = document.getElementById('participant-form');
        const reactionBox = document.getElementById('reaction-box');
        const countdownText = document.getElementById('countdown-text');
        const statusDisplay = document.getElementById('status-display');
        const lastRtDisplay = document.getElementById('last-rt-display');
        const btnPauseResume = document.getElementById('btn-pause-resume');
        const btnFixedPractice = document.getElementById('btn-fixed-practice');
        const btnVariablePractice = document.getElementById('btn-variable-practice');
        const btnTestVariable = document.getElementById('btn-test-variable');
        const btnTestFixed = document.getElementById('btn-test-fixed');
        const btnResults = document.getElementById('btn-results');
        const btnDownloadCSV = document.getElementById('btn-download-csv');
        const fullNameInput = document.getElementById('full-name');
        const nameErrorDisplay = document.getElementById('name-error');

        // --- Game State (Updated with sequential flags) ---
        window.gameState = {
            participant: null, 
            mode: 'none', 
            isRunning: false,
            isPaused: false,
            isWaitingForCue: false,
            isWaitingForReaction: false,
            
            hasStartedFixedPractice: false,
            hasStartedVariablePractice: false,
            hasCompletedTraining: false, 
            hasCompletedTest1: false, 
            isSessionComplete: false, 
            
            currentRound: 0,
            totalRounds: 0,
            intervalArray: [], 
            intervalIndex: 0,
            timers: {
                countdown: null,
                cue: null,
                timeout: null,
                delay: null
            },
            startTime: 0, 
            cueTime: 0, 
            results: []
        };
        let gameState = window.gameState; 

        // --- Utility Functions ---
        
        function randomizeArray(array) {
            let currentIndex = array.length, randomIndex;
            let arr = [...array]; // Create a copy
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [arr[currentIndex], arr[randomIndex]] = [
                    arr[currentIndex], arr[randomIndex]
                ];
            }
            return arr;
        }

        function updateStatus(text, color = 'text-gray-800') {
            statusDisplay.textContent = text;
            statusDisplay.className = `text-lg font-bold absolute left-1/2 transform -translate-x-1/2 ${color}`;
        }
        
        function clearAllTimers() {
            Object.values(gameState.timers).forEach(timer => {
                if (timer) clearTimeout(timer);
                if (timer) clearInterval(timer);
            });
            gameState.timers = { countdown: null, cue: null, timeout: null, delay: null };
        }

        // --- UI State Management ---

        function updateModeButtons() {
            const disableAllModes = gameState.isRunning || gameState.isPaused;

            const hasStartedAnyTraining = gameState.hasStartedFixedPractice || gameState.hasStartedVariablePractice;
            
            btnFixedPractice.disabled = disableAllModes || hasStartedAnyTraining;
            btnVariablePractice.disabled = disableAllModes || hasStartedAnyTraining;
            
            btnTestVariable.disabled = disableAllModes || !gameState.hasCompletedTraining || gameState.hasCompletedTest1;
            
            btnTestFixed.disabled = disableAllModes || !gameState.hasCompletedTest1;

            btnPauseResume.disabled = !gameState.isRunning;
            if (gameState.isPaused) {
                btnPauseResume.textContent = '▶'; 
            } else {
                btnPauseResume.textContent = '⏸'; 
            }
        }

        function togglePause() {
            if (!gameState.isRunning) return;

            gameState.isPaused = !gameState.isPaused;
            if (gameState.isPaused) {
                clearAllTimers();
                reactionBox.classList.remove('flash-cue'); 
                countdownText.textContent = 'Paused';
                updateStatus('Paused', 'text-orange-500');
            } else {
                updateStatus(`Resumed. Restarting Round ${gameState.currentRound}...`, 'text-green-500');
                gameState.timers.delay = setTimeout(restartCurrentRound, 500); 
            }
            updateModeButtons();
        }

        function restartCurrentRound() {
            if (gameState.isPaused || !gameState.isRunning) return;
            startCountdown();
        }

        function cueFlash() {
            gameState.cueTime = Date.now();
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = true;
            
            reactionBox.classList.add('flash-cue');
            countdownText.textContent = ''; 
            updateStatus('REACT NOW!', 'text-blue-500');

            gameState.timers.timeout = setTimeout(handleTimeout, MISSED_TIMEOUT_MS);
        }

        function startCountdown() {
            if (gameState.isPaused || !gameState.isRunning) return;

            let count = 3;
            reactionBox.classList.remove('flash-cue', 'bg-red-400', 'text-white');
            countdownText.textContent = count;
            updateStatus(`Round ${gameState.currentRound}/${gameState.totalRounds}. Get Ready...`);
            
            if (gameState.timers.countdown) clearInterval(gameState.timers.countdown);

            gameState.timers.countdown = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else {
                    clearInterval(gameState.timers.countdown);
                    countdownText.textContent = ''; 
                    updateStatus('WAIT for the flash', 'text-gray-700');
                    startRoundTimer();
                }
            }, 1000);
        }

        function nextRound() {
            if (gameState.isPaused || !gameState.isRunning || gameState.isSessionComplete) return;

            gameState.currentRound++; 
            
            if (gameState.currentRound > gameState.totalRounds) {
                endSession();
                return;
            }
            
            if (gameState.mode === 'variable-practice') {
                gameState.intervalIndex++;
            }
            
            startCountdown();
        }

        function endSession() {
            clearAllTimers();
            gameState.isRunning = false;
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = false;
            gameState.isSessionComplete = true; 

            // --- CRITICAL STEP: Save results locally ---
            window.saveResults(gameState.mode, gameState.totalRounds, gameState.results);

            let message = '';
            let statusColor = '';
            
            if (gameState.mode === 'fixed-practice' || gameState.mode === 'variable-practice') { 
                gameState.hasCompletedTraining = true;
                message = 'Training Complete!';
                statusColor = 'text-green-700';
            } else if (gameState.mode === 'variable-test') {
                gameState.hasCompletedTest1 = true;
                message = 'Test 1 Complete!';
                statusColor = 'text-green-700';
            } else if (gameState.mode === 'fixed-test') {
                message = 'All Tests Complete!';
                statusColor = 'text-blue-700';
            }

            countdownText.textContent = message;
            updateStatus(message, statusColor);
            updateModeButtons();
        }

        function handleHit() {
            clearTimeout(gameState.timers.timeout); 

            const reactionTime = Date.now() - gameState.cueTime;
            const interval = gameState.cueTime - gameState.startTime;

            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: interval,
                rt: reactionTime,
                status: 'HIT'
            });

            reactionBox.classList.remove('flash-cue');
            countdownText.textContent = `${reactionTime.toFixed(0)} ms`;
            lastRtDisplay.textContent = `Last RT: ${reactionTime.toFixed(0)} ms`;
            updateStatus('HIT!', 'text-green-600');
            
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(nextRound, POST_TRIAL_DELAY_MS);
        }

        function handleFalseStart() {
            clearAllTimers();
            
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: null,
                rt: null,
                status: 'FALSE START'
            });

            countdownText.textContent = 'FALSE START';
            reactionBox.classList.add('bg-red-400', 'text-white');
            reactionBox.classList.remove('flash-cue');
            updateStatus('FALSE START! Restarting round...', 'text-red-600');
            
            gameState.isWaitingForCue = false;
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(() => {
                restartCurrentRound(); 
            }, 500); 
        }
        
        function handleTimeout() {
            clearAllTimers();
            
            gameState.results.push({
                round: gameState.currentRound,
                mode: gameState.mode,
                interval: gameState.cueTime - gameState.startTime,
                rt: null,
                status: 'MISSED'
            });

            countdownText.textContent = 'MISSED';
            reactionBox.classList.remove('flash-cue');
            updateStatus('MISSED! Starting next round...', 'text-yellow-600');
            
            gameState.isWaitingForReaction = false;

            gameState.timers.delay = setTimeout(nextRound, POST_TRIAL_DELAY_MS);
        }

        function startRoundTimer() {
            gameState.isWaitingForCue = true;
            gameState.startTime = Date.now();

            let interval;
            
            // For Reaction Test 1, the interval is always fixed for true reaction measurement
            if (gameState.mode === 'variable-test') {
                 interval = 2360; 
            } 
            // For Reaction Test 2 and Fixed Practice, interval is fixed
            else if (gameState.mode === 'fixed-practice' || gameState.mode === 'fixed-test') {
                interval = FIXED_INTERVAL_MS; 
            } 
            // For Variable Practice, use the randomized array
            else if (gameState.mode === 'variable-practice') {
                interval = gameState.intervalArray[gameState.intervalIndex];
            } else {
                console.error("Unknown game mode:", gameState.mode);
                interval = FIXED_INTERVAL_MS;
            }

            gameState.timers.cue = setTimeout(cueFlash, interval);
        }

        function startSession(mode, totalRounds) {
            if (gameState.isSessionComplete && gameState.isRunning) return; 

            clearAllTimers();

            if (mode === 'fixed-practice') gameState.hasStartedFixedPractice = true;
            if (mode === 'variable-practice') gameState.hasStartedVariablePractice = true;
            
            gameState.mode = mode;
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.isSessionComplete = false; 
            gameState.currentRound = 0; 
            gameState.totalRounds = totalRounds;
            gameState.results = [];
            
            if (mode === 'variable-practice') {
                gameState.intervalArray = randomizeArray(VARIABLE_INTERVALS_MS);
                gameState.intervalIndex = 0;
            } else {
                gameState.intervalArray = [];
                gameState.intervalIndex = 0;
            }

            btnPauseResume.disabled = false;
            updateModeButtons();
            
            nextRound(); 
        }
        
        // --- Session Saving Logic (Replaces Firestore/GAS) ---
        window.saveResults = function(mode, totalRounds, results) {
            const dataToSave = {
                id: crypto.randomUUID(), // Unique ID for this session
                participant: gameState.participant, 
                mode: mode,
                totalRounds: totalRounds,
                timestamp: new Date().toISOString(),
                results: results
            };
            
            saveLocalSession(dataToSave);
            console.log("Session results saved successfully to Local Storage.");
        };

        function formatMode(mode) {
            switch (mode) {
                case 'fixed-practice': return 'Training Set A (Fixed)';
                case 'variable-practice': return 'Training Set B (Variable)';
                case 'variable-test': return 'Reaction Test 1 (Variable Cue)';
                case 'fixed-test': return 'Reaction Test 2 (Fixed Cue)';
                default: return mode;
            }
        }
        
        /**
         * Converts all stored data into a CSV format and triggers a download.
         */
        window.downloadCSV = function() {
            const allSessions = loadLocalResults();
            if (allSessions.length === 0) {
                alert("No results to download."); // Using alert here for simple download failure
                return;
            }

            const header = [
                "Session ID", "Participant Name", "Grade Level", "Sex", "Session Mode", 
                "Timestamp", "Round Number", "RT (ms)", "Status", "Cue Interval (ms)"
            ];
            let csv = header.join(',') + '\n';

            allSessions.forEach(session => {
                const baseData = [
                    session.id, 
                    session.participant.fullName.replace(/,/g, ''), // Remove commas from names
                    session.participant.gradeLevel, 
                    session.participant.sex,
                    formatMode(session.mode).replace(/,/g, ''),
                    new Date(session.timestamp).toLocaleString()
                ].map(v => `"${v}"`).join(','); // Quote base data

                session.results.forEach(result => {
                    const rowData = [
                        result.round,
                        result.rt !== null ? result.rt.toFixed(0) : 'N/A',
                        result.status,
                        result.interval !== null ? result.interval.toFixed(0) : 'N/A'
                    ].map(v => `"${v}"`).join(','); // Quote result data

                    csv += baseData.slice(0, -1) + rowData + '\n';
                });
            });

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `ReactionTrainer_Results_${new Date().toISOString().slice(0, 10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        };

        /**
         * Fetches and displays all historical results from Local Storage.
         */
        window.showAllHistoricalResults = function() {
            const loadingMessage = document.getElementById('results-loading-message');
            const resultsTable = document.getElementById('results-table');
            const resultsTableBody = document.getElementById('results-table-body');
            
            document.getElementById('results-modal').classList.remove('hidden');

            const allSessions = loadLocalResults();
            
            resultsTableBody.innerHTML = ''; // Clear previous results
            
            if (allSessions.length === 0) {
                loadingMessage.textContent = 'No past sessions found.';
                loadingMessage.classList.remove('hidden');
                resultsTable.classList.add('hidden');
                btnDownloadCSV.disabled = true;
                return; 
            }
            
            btnDownloadCSV.disabled = false;
            loadingMessage.classList.add('hidden');
            resultsTable.classList.remove('hidden');


            const modeOrder = {
                'fixed-practice': 1,
                'variable-practice': 1,
                'variable-test': 2,
                'fixed-test': 3
            };

            // Sort all sessions first by type, then by timestamp
            allSessions.sort((a, b) => {
                const orderA = modeOrder[a.mode] || 99;
                const orderB = modeOrder[b.mode] || 99;
                
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                return new Date(a.timestamp) - new Date(b.timestamp);
            });

            let totalHits = 0;
            let totalFalseStarts = 0;
            let totalMissed = 0;
            let totalRounds = 0;
            let allRts = [];
            let participantName = allSessions[0].participant?.fullName || 'N/A';
            
            allSessions.forEach(session => {
                session.results.forEach(result => {
                    if (result.status === 'HIT' && result.rt !== null) {
                        allRts.push(result.rt);
                    }
                });
                totalRounds += session.totalRounds;
                totalHits += session.results.filter(r => r.status === 'HIT').length;
                totalFalseStarts += session.results.filter(r => r.status === 'FALSE START').length;
                totalMissed += session.results.filter(r => r.status === 'MISSED').length;
            });
            
            const overallAvgRt = allRts.length > 0 ? (allRts.reduce((a, b) => a + b, 0) / allRts.length).toFixed(0) : '--';

            // --- 2. Update Summary Area ---
            document.getElementById('participant-name').textContent = participantName; 
            document.getElementById('results-total-sessions').textContent = allSessions.length;
            document.getElementById('results-total-rounds').textContent = totalRounds;
            document.getElementById('results-avg-rt').textContent = overallAvgRt;
            document.getElementById('results-hits').textContent = totalHits;
            document.getElementById('results-false-starts').textContent = totalFalseStarts;
            document.getElementById('results-missed').textContent = totalMissed;

            // --- 3. Populate Unified Breakdown Table ---
            allSessions.forEach((session) => {
                const displayMode = formatMode(session.mode);
                
                const sessionHits = session.results.filter(r => r.status === 'HIT');
                const sessionAvgRt = sessionHits.length > 0 ? (sessionHits.map(r => r.rt).reduce((a, b) => a + b, 0) / sessionHits.length).toFixed(0) : '--';
                
                const headerRow = resultsTableBody.insertRow();
                headerRow.className = 'text-sm bg-blue-100 font-bold border-t-4 border-blue-400';
                headerRow.innerHTML = `
                    <td class="px-3 py-2 whitespace-nowrap" colspan="4">
                        ${displayMode} (Session Avg RT: ${sessionAvgRt} ms, Date: ${new Date(session.timestamp).toLocaleDateString()})
                    </td>
                `;

                session.results.forEach((result, index) => {
                    const row = resultsTableBody.insertRow();
                    row.className = 'text-sm ' + (index % 2 === 0 ? 'bg-white' : 'bg-gray-50'); 
                    
                    const rtDisplay = result.rt !== null ? result.rt.toFixed(0) : '--';
                    let statusClass = 'text-gray-500';
                    if (result.status === 'HIT') statusClass = 'text-green-600 font-bold';
                    else if (result.status === 'FALSE START') statusClass = 'text-red-600 font-bold';

                    row.innerHTML = `
                        <td class="px-3 py-2 whitespace-nowrap">${displayMode}</td>
                        <td class="px-3 py-2 whitespace-nowrap">${result.round}</td>
                        <td class="px-3 py-2 whitespace-nowrap">${rtDisplay}</td>
                        <td class="px-3 py-2 whitespace-nowrap">
                            <span class="${statusClass}">${result.status}</span>
                        </td>
                    `;
                });
                
                const falseStartCount = session.results.filter(r => r.status === 'FALSE START').length;
                const summaryRow = resultsTableBody.insertRow();
                summaryRow.className = 'text-base bg-yellow-100 font-semibold border-b-2 border-yellow-400'; 
                summaryRow.innerHTML = `
                    <td class="px-3 py-2 whitespace-nowrap" colspan="3">Total False Starts for this session:</td>
                    <td class="px-3 py-2 whitespace-nowrap text-red-600">${falseStartCount}</td>
                `;
            });
        };
        
        window.handleReaction = function(event) {
            if (gameState.isPaused || !gameState.isRunning || gameState.isSessionComplete) return;

            if (gameState.isWaitingForReaction) {
                handleHit();
            } else if (gameState.isWaitingForCue) {
                handleFalseStart();
            } else {
                console.log("Reaction ignored. Not cue or reaction phase.");
            }
        }


        // --- Event Listeners and Initialization ---

        participantForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            
            const fullName = formData.get('fullName').trim();
            const gradeLevel = parseInt(formData.get('gradeLevel'));
            const sex = formData.get('sex');
            
            nameErrorDisplay.classList.add('hidden'); 

            const nameRegex = /^[A-Za-z\s.'-]+$/; 
            
            if (fullName.length < 2) {
                nameErrorDisplay.textContent = "Please enter your full name (at least two characters).";
                nameErrorDisplay.classList.remove('hidden');
                return; 
            }
            
            if (!nameRegex.test(fullName)) {
                nameErrorDisplay.textContent = "Name contains invalid characters. Use only letters, spaces, hyphens, apostrophes, or periods.";
                nameErrorDisplay.classList.remove('hidden');
                return; 
            }
            
            if (gradeLevel < 1 || gradeLevel > 12) {
                console.error("Grade level out of range.");
                return; 
            }
            
            gameState.participant = {
                fullName: fullName,
                gradeLevel: gradeLevel,
                sex: sex
            };
            
            // Save participant data to local storage
            localStorage.setItem('participantData', JSON.stringify(gameState.participant));

            infoModal.classList.add('hidden');
            countdownText.textContent = 'Welcome';
            updateStatus('Ready. Choose a Training Set.');
            updateModeButtons(); 
        });

        document.querySelectorAll('.btn-mode').forEach(button => {
            button.addEventListener('click', (e) => {
                if (e.target.disabled) return; 

                const id = e.target.id;
                let mode, rounds;

                if (id === 'btn-fixed-practice') { 
                    mode = 'fixed-practice';
                    rounds = PRACTICE_ROUNDS;
                } else if (id === 'btn-variable-practice') { 
                    mode = 'variable-practice';
                    rounds = PRACTICE_ROUNDS;
                } else if (id === 'btn-test-variable') { 
                    mode = 'variable-test';
                    rounds = SINGLE_ROUND; 
                } else if (id === 'btn-test-fixed') { 
                    mode = 'fixed-test';
                    rounds = SINGLE_ROUND; 
                } else { 
                    return;
                }

                if (gameState.participant) {
                    startSession(mode, rounds);
                } else {
                    countdownText.textContent = "Please provide participant info first.";
                    updateStatus('Start Experiment Required', 'text-red-500');
                    infoModal.classList.remove('hidden');
                }
            });
        });

        btnPauseResume.addEventListener('click', togglePause);

        // Listener for the global click handler on the results button
        btnResults.addEventListener('click', () => {
             window.showAllHistoricalResults();
        });


        reactionBox.addEventListener('click', window.handleReaction);

        document.onkeydown = function(e) {
            if (e.key === ' ' || e.key === 'Spacebar') {
                
                // Check if the user is typing in an input field. If so, let them type a space.
                const activeTag = document.activeElement.tagName;
                const activeType = document.activeElement.type;
                const isTyping = (activeTag === 'INPUT' || activeTag === 'TEXTAREA') && 
                                 (activeType === 'text' || activeType === 'number');

                if (isTyping) {
                    return; 
                }

                e.preventDefault(); 

                // 1. If paused, spacebar resumes (addresses user request)
                if (gameState.isRunning && gameState.isPaused) {
                    togglePause();
                    return;
                }
                
                // 2. If running (or waiting for a cue), spacebar acts as reaction
                if (gameState.isRunning) {
                    window.handleReaction(e);
                    return;
                }
            }
        };

        window.addEventListener('blur', () => {
            if (gameState.isRunning && !gameState.isPaused) {
                togglePause(); 
            }
        });
        
        // --- Immediate Initial Setup ---
        
        // Load participant data from local storage on startup
        const storedParticipant = localStorage.getItem('participantData');
        if (storedParticipant) {
            try {
                gameState.participant = JSON.parse(storedParticipant);
                infoModal.classList.add('hidden');
            } catch (e) {
                console.error("Failed to parse stored participant data.");
                localStorage.removeItem('participantData');
            }
        }
        
        updateStatus('Ready');
        updateModeButtons();
    </script>
</body>
</html>
