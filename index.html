<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Motor Skill Acquisition — Blocked & Random Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html,body,#app{height:100%;margin:0}
        body{font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;background:#f3f7fb}
        .game-grid{display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(2,1fr);gap:0.75rem;padding:0.75rem;height:calc(100vh - 136px)}
        /* Removed border and shadow transitions from tile to prevent flickering when color is added/removed */
        .tile{display:flex;align-items:center;justify-content:center;font-weight:700;font-size:2.25rem;border-radius:12px;background:#fff;border:3px solid #cbd5e1;user-select:none; }
        .tile:focus{outline:3px solid #60a5fa}
        .disabled{pointer-events:none;opacity:0.75}
        .status{height:72px;padding:0.75rem}
        @keyframes flash {0%{opacity:0.15}50%{opacity:1}100%{opacity:0.15}}
        .flashing{animation:flash 300ms ease-in-out infinite}
        
        /* Removed the previous .pressed-tile styles. The color class itself will now provide the feedback. */
        /* Modal Styling */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; max-width: 90%; width: 500px; max-height: 80%; overflow: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-content pre {
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
        }
        /* Tailwind colors used for feedback - ensures background color and white text */
        .bg-blue-500 { background-color: #3b82f6; color: white !important; }
        .bg-green-500 { background-color: #22c55e; color: white !important; }
        .bg-red-500 { background-color: #ef4444; color: white !important; }
        .bg-yellow-400 { background-color: #facc15; color: white !important; }

    </style>
</head>
<body>
    <div class="status bg-white border-b border-gray-200 flex items-center justify-between px-4">
        <div>
            <div class="text-sm text-gray-600">Motor Skill Acquisition — Blocked vs Random</div>
            <div id="phase" class="text-lg font-semibold">Ready</div>
        </div>
        <div class="text-center">
            <div id="cue-indicator" class="text-sm">Cue: -</div>
            <div id="trial-display" class="text-xs text-gray-500">Trial 0/0</div>
        </div>
        <div class="flex items-center gap-3">
            <div id="user-id" class="text-xs text-gray-500">User: Anonymous</div>
            <button id="download-btn" class="px-3 py-1 bg-gray-400 text-white rounded" onclick="window.downloadResults()">Download Results (TXT)</button>
        </div>
    </div>

    <div class="p-3 bg-white flex gap-3 items-center">
        <button id="blocked-btn" class="px-4 py-2 bg-indigo-600 text-white rounded shadow" onclick="startBlocked()">Practice 1</button>
        <button id="random-btn" class="px-4 py-2 bg-sky-600 text-white rounded shadow" onclick="startRandom()">Practice 2</button>
        <button id="test1-btn" class="px-4 py-2 bg-purple-600 text-white rounded shadow" onclick="startTest(1)">Test 1</button>
        <button id="test2-btn" class="px-4 py-2 bg-pink-600 text-white rounded shadow" onclick="startTest(2)">Test 2</button>
        
        <button id="view-results-btn" class="px-4 py-2 bg-green-600 text-white rounded shadow" onclick="window.displayResults()">View Results</button>
        
        <div class="ml-auto text-sm text-gray-700">Last Trial: <span id="last-summary">-</span></div>
    </div>

    <main id="app">
        <div id="grid" class="game-grid" role="application" aria-label="6 button grid">
            <button class="tile tile-1" data-box="1" aria-label="box 1">1</button>
            <button class="tile tile-2" data-box="2" aria-label="box 2">2</button>
            <button class="tile tile-3" data-box="3" aria-label="box 3">3</button>
            <button class="tile tile-4" data-box="4" aria-label="box 4">4</button>
            <button class="tile tile-5" data-box="5" aria-label="box 5">5</button>
            <button class="tile tile-6" data-box="6" aria-label="box 6">6</button>
        </div>
    </main>
    
    <div id="instruction-modal" class="modal" onclick="this.style.display='none'">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2 id="instruction-title" class="text-xl font-bold mb-3">Phase Instructions</h2>
            <p id="instruction-text" class="mb-4 text-gray-700">Detailed instructions go here.</p>
            <button id="instruction-start-btn" class="mt-4 px-4 py-2 bg-indigo-600 text-white rounded" onclick="window.instructionStartAction()">Start</button>
            <button class="mt-4 px-4 py-2 bg-gray-500 text-white rounded" onclick="document.getElementById('instruction-modal').style.display='none'">Cancel</button>
        </div>
    </div>

    <div id="results-modal" class="modal" onclick="this.style.display='none'">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2 class="text-xl font-bold mb-3">Your Session Results</h2>
            <pre id="results-display"></pre>
            <button class="mt-4 px-4 py-2 bg-gray-500 text-white rounded" onclick="document.getElementById('results-modal').style.display='none'">Close</button>
        </div>
    </div>

    <script>
        const PATTERNS = {
            blue: { sequence: [3,6,4], colorClass: 'bg-blue-500', name:'BLUE' },
            green: { sequence: [2,5,1], colorClass: 'bg-green-500', name:'GREEN' },
            red: { sequence: [5,3,6], colorClass: 'bg-red-500', name:'RED' },
            yellow: { sequence: [3,4,1], colorClass: 'bg-yellow-400', name:'YELLOW' }
        };
        const ALL_COLOR_CLASSES = ['bg-blue-500', 'bg-green-500', 'bg-red-500', 'bg-yellow-400'];

        const TRIALS_PER_BLOCK = 15; 
        const TEST_PAUSE_MS = 5000; 
        const PRACTICE_AVG_BLOCK_SIZE = 10; 

        const tiles = Array.from(document.querySelectorAll('.tile'));
        const phaseEl = document.getElementById('phase');
        const cueEl = document.getElementById('cue-indicator');
        const trialDisplay = document.getElementById('trial-display');
        const lastSummary = document.getElementById('last-summary');
        const test1Btn = document.getElementById('test1-btn');
        const test2Btn = document.getElementById('test2-btn');
        const blockedBtn = document.getElementById('blocked-btn');
        const randomBtn = document.getElementById('random-btn');
        const resultsModal = document.getElementById('results-modal');
        const resultsDisplay = document.getElementById('results-display');
        
        // Instruction Modal elements
        const instructionModal = document.getElementById('instruction-modal');
        const instructionTitle = document.getElementById('instruction-title');
        const instructionText = document.getElementById('instruction-text');

        // Variables to store pending phase details
        let pendingMode = 'idle';
        let pendingQueue = [];
        let pendingPracticeType = null;
        
        let mode = 'idle';
        let learningOrder = ['blue','green','red','yellow'];
        let practiceQueue = [];
        let currentPatternKey = null;
        let currentExpectedSeq = [];
        let clickBuffer = [];
        let startTime = null;
        let isDuringCue = false;
        let isActive = false;
        let trialIndex = 0;
        let results = [];
        let practiceType = null; 

        // Helper to remove all color/style feedback from tiles
        function resetTileAppearance() {
            tiles.forEach(t => {
                // Remove all possible color classes
                ALL_COLOR_CLASSES.forEach(c => t.classList.remove(c));
                t.style.color = ''; // Reset text color
            });
        }

        tiles.forEach(t=>{ t.addEventListener('keydown',(e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); t.click(); } }); });

        function updateStatus(phaseText, cueText='', trialText=''){
            phaseEl.textContent = phaseText;
            cueEl.textContent = cueText?`Cue: ${cueText}`:'Cue: -';
            if(trialText) trialDisplay.textContent = trialText;
        }

        function setTilesDisabled(disabled){ tiles.forEach(t=>{ t.classList.toggle('disabled', disabled); t.disabled = disabled; }); }

        async function flashSequence(patternKey, showPattern=true){
            return new Promise(async (resolve)=>{
                isDuringCue = true; setTilesDisabled(true);
                resetTileAppearance(); // Clear feedback when a new cue starts

                const pat = PATTERNS[patternKey];
                updateStatus(mode.toUpperCase(), pat.name, `${trialIndex+1}/${practiceQueue.length || 0}`);

                document.body.style.transition = 'background-color 0.2s';
                document.body.style.backgroundColor = pat.colorClass.includes('blue')? '#3b82f6' : pat.colorClass.includes('green')? '#22c55e' : pat.colorClass.includes('red')? '#ef4444' : '#facc15';
                await delay(600);
                document.body.style.backgroundColor = '#f3f7fb';
                await delay(300);

                if(showPattern){
                    for(const b of pat.sequence){
                        const el = document.querySelector(`.tile-${b}`);
                        el.classList.add(pat.colorClass);
                        el.style.color = '#fff'; // Set text color to white for contrast
                        await delay(500); 
                        el.classList.remove(pat.colorClass);
                        el.style.color = ''; // Reset text color
                        await delay(200);
                    }
                }
                isDuringCue = false; 
                startTime = performance.now(); 
                setTilesDisabled(false);
                resolve();
            });
        }

        function delay(ms){ return new Promise(r=>setTimeout(r,ms)); }
        
        async function countdownDelay(ms) {
            let seconds = Math.floor(ms / 1000);
            const originalPhaseText = phaseEl.textContent;

            for (let i = seconds; i > 0; i--) {
                phaseEl.textContent = `${originalPhaseText} (Next in ${i}s...)`;
                await delay(1000);
            }
        }


        function resetTrialVars(){ 
            clickBuffer = []; 
            startTime = null; 
        }

        tiles.forEach(t=> t.addEventListener('click', async ()=>{
            if(isDuringCue || !isActive) return;
            const box = parseInt(t.dataset.box,10);
            
            const pat = PATTERNS[currentPatternKey];
            const clickedTile = t;
            
            // APPLY COLOR: Re-add the pattern's color class to the clicked tile
            // This ensures the color from the cue phase "sticks"
            clickedTile.classList.add(pat.colorClass);
            clickedTile.style.color = '#fff';

            // Brief opacity flash for visual confirmation of the click
            clickedTile.classList.add('opacity-80'); setTimeout(()=> clickedTile.classList.remove('opacity-80'),120);
            clickBuffer.push(box);

            if(clickBuffer.length === currentExpectedSeq.length){
                const rt = (performance.now() - startTime)/1000;
                isActive = false; setTilesDisabled(true);
                let correct = 0; for(let i=0;i<currentExpectedSeq.length;i++){ if(clickBuffer[i] === currentExpectedSeq[i]) correct++; }
                const score = correct / currentExpectedSeq.length;
                const result = { 
                    phase: mode, 
                    trialNumber: trialIndex+1, 
                    pattern: currentPatternKey, 
                    expected: currentExpectedSeq, 
                    actual: clickBuffer, 
                    reactionTime_s: parseFloat(rt.toFixed(3)), 
                    correct: correct, 
                    score: score,
                    expectedLength: currentExpectedSeq.length
                };
                lastSummary.textContent = `${result.pattern.toUpperCase()}: ${result.correct}/${currentExpectedSeq.length}, ${result.reactionTime_s}s`;
                results.push(result);
                
                const isLastTrial = (trialIndex + 1) >= practiceQueue.length;

                if(mode === 'test1' && !isLastTrial){ 
                    updateStatus('Waiting before next cue...', '', `${trialIndex+1}/${practiceQueue.length}`); 
                    await countdownDelay(TEST_PAUSE_MS); 
                } 
                
                // The color will persist until flashSequence() calls resetTileAppearance()
                
                trialIndex++;
                await nextTrial();
            }
        }));

        async function nextTrial(){
            if(mode === 'blocked' || mode === 'random'){
                if(trialIndex >= practiceQueue.length){
                    updateStatus('Practice complete');
                    test1Btn.disabled = false; test2Btn.disabled = false;
                    mode = 'idle'; setTilesDisabled(true);
                    resetTileAppearance(); // Clear feedback when the practice phase ends
                    return;
                }
                currentPatternKey = practiceQueue[trialIndex];
                currentExpectedSeq = PATTERNS[currentPatternKey].sequence.slice();
                
                resetTrialVars(); 
                await flashSequence(currentPatternKey, true); 
                isActive = true; 
            }else if(mode === 'test1' || mode === 'test2'){
                if(trialIndex >= practiceQueue.length){ 
                    updateStatus('Test complete');
                    setTilesDisabled(true); 
                    
                    if(mode === 'test1') { test1Btn.disabled = true; }
                    if(mode === 'test2') { test2Btn.disabled = true; }

                    if(mode === 'test1') { test2Btn.disabled = false; }
                    
                    mode='idle';
                    resetTileAppearance(); // Clear feedback when the test phase ends
                    return; 
                }
                currentPatternKey = practiceQueue[trialIndex];
                currentExpectedSeq = PATTERNS[currentPatternKey].sequence.slice();
                
                resetTrialVars(); 
                await flashSequence(currentPatternKey, false); 
                isActive = true; 
            }
        }

        function buildBlockedQueue(){ const q=[]; for(const p of learningOrder){ for(let i=0;i<TRIALS_PER_BLOCK;i++) q.push(p); } return q; }
        function buildRandomQueue(){
            const q=[]; 
            for(const p of Object.keys(PATTERNS)){
                for(let i=0;i<TRIALS_PER_BLOCK;i++) q.push(p);
            }
            let seed = 12345;
            function seededRandom(){ seed = (seed * 16807) % 2147483647; return (seed-1)/2147483646; }
            for(let i=q.length-1;i>0;i--){ const j = Math.floor(seededRandom()* (i+1)); [q[i],q[j]]=[q[j],q[i]]; }
            return q; 
        }

        // --- NEW MODAL LOGIC (No changes here, copied from previous step) ---
        function showInstructionsModal(title, text) {
            instructionTitle.textContent = title;
            instructionText.innerHTML = text;
            instructionModal.style.display = 'flex';
        }

        window.instructionStartAction = async function() {
            instructionModal.style.display = 'none';

            if (pendingMode === 'blocked' || pendingMode === 'random') {
                blockedBtn.disabled = true;
                randomBtn.disabled = true;
            }
            
            if (pendingMode === 'test1') { test1Btn.disabled = true; }
            if (pendingMode === 'test2') { test2Btn.disabled = true; }
            
            mode = pendingMode;
            practiceQueue = pendingQueue;
            practiceType = pendingPracticeType;
            trialIndex = 0;
            
            updateStatus(mode.toUpperCase() + ' started');
            await nextTrial();
        }

        function startBlocked(){
            blockedBtn.disabled = true; 
            randomBtn.disabled = true;
            test1Btn.disabled = true; 
            test2Btn.disabled = true;

            pendingMode = 'blocked';
            pendingPracticeType = 'Practice 1'; 
            pendingQueue = buildBlockedQueue();
            
            const title = "Practice 1 (Blocked)";
            const text = "In this phase, you will practice each sequence (**BLUE**, **GREEN**, **RED**, **YELLOW**) in blocks of 15 trials before moving to the next sequence.<br><br>The sequence will be shown to you first. Try to memorize and reproduce the sequence of three button clicks as quickly and accurately as possible after the screen cues you with the pattern color.";

            showInstructionsModal(title, text);
        }

        function startRandom(){
            blockedBtn.disabled = true; 
            randomBtn.disabled = true;
            test1Btn.disabled = true; 
            test2Btn.disabled = true;

            pendingMode = 'random';
            pendingPracticeType = 'Practice 2'; 
            pendingQueue = buildRandomQueue();

            const title = "Practice 2 (Random)";
            const text = "In this phase, the sequences (**BLUE**, **GREEN**, **RED**, **YELLOW**) will be presented in a completely random order across all trials.<br><br>The sequence will be shown to you first. Try to memorize and reproduce the sequence of three button clicks as quickly and accurately as possible after the screen cues you with the pattern color. Remember, the sequence changes frequently!";
            
            showInstructionsModal(title, text);
        }

        function startTest(which){
            blockedBtn.disabled = true; 
            randomBtn.disabled = true;
            test1Btn.disabled = true; 
            test2Btn.disabled = true;

            if(which===1){ 
                pendingMode = 'test1'; 
                pendingQueue = learningOrder.slice(); 
                const title = "Test 1";
                const text = "This is the **Test 1** phase. You must reproduce the learned sequences.<br><br>You will **NOT** see the sequence flash on the grid. Only the **color cue** will appear. Immediately after the cue, perform the required sequence (3 clicks) as quickly as you can.";
                showInstructionsModal(title, text);
            } else { 
                pendingMode = 'test2'; 
                pendingQueue = ['red','yellow','blue','green']; 
                const title = "Test 2";
                const text = "This is the **Test 2** phase. This test is similar to Test 1, but uses a different set of sequences to measure transfer.<br><br>You will **NOT** see the sequence flash on the grid. Only the **color cue** will appear. Immediately after the cue, perform the required sequence (3 clicks) as quickly as you can.";
                showInstructionsModal(title, text);
            }
        }
        // --- END NEW MODAL LOGIC ---


        window.resetGame = ()=>{
            mode='idle'; practiceQueue=[]; currentPatternKey=null; clickBuffer=[]; trialIndex=0; setTilesDisabled(true);
            resetTileAppearance(); 
            test1Btn.disabled = false; 
            test2Btn.disabled = false; 
            blockedBtn.disabled=false; 
            randomBtn.disabled=false; 
            updateStatus('Ready'); lastSummary.textContent='-';
        };
        document.addEventListener('DOMContentLoaded', ()=>{ window.resetGame(); });

        // Helper function to calculate averages for a given set of data
        function calculateAverages(data) {
            if (data.length === 0) return { avgAccuracy: 0, avgSpeed: 0 };
            const totalCorrect = data.reduce((sum, d) => sum + d.correct, 0);
            const totalPossible = data.reduce((sum, d) => sum + d.expectedLength, 0);
            const totalSpeed = data.reduce((sum, d) => sum + d.reactionTime_s, 0);
            
            const avgAccuracy = (totalPossible > 0) ? ((totalCorrect / totalPossible) * 100).toFixed(1) : 0;
            const avgSpeed = (data.length > 0) ? (totalSpeed / data.length).toFixed(3) : 0;
            
            return {
                avgAccuracy: avgAccuracy, 
                avgSpeed: avgSpeed,
                totalPossible: totalPossible
            };
        }

        // --- CORE FUNCTION TO GENERATE RESULTS TEXT (No changes here, copied from previous step) ---
        window.generateResultsText = function(){
            if(results.length === 0){ return "No results recorded. Please complete a practice or test phase first."; }

            const practiceResults = results.filter(r => r.phase === 'blocked' || r.phase === 'random');
            const test1Results = results.filter(r => r.phase === 'test1');
            const test2Results = results.filter(r => r.phase === 'test2');
            
            const practiceMode = practiceType || (practiceResults.length > 0 ? (practiceResults[0].phase === 'blocked' ? 'Practice 1' : 'Practice 2') : 'N/A');

            let txtData = [];
            
            txtData.push(`--- Motor Skill Acquisition Results ---`);
            txtData.push(`Practice Type: ${practiceMode}`);
            txtData.push(`Date/Time: ${new Date().toLocaleString()}`);
            txtData.push(`-------------------------------------`);
            
            
            const practicePhaseName = practiceMode; 
            if (practiceResults.length > 0) {
                txtData.push(`\n## ${practicePhaseName.toUpperCase()} DETAILS (Total Trials: ${practiceResults.length})`);

                for (let i = 0; i < practiceResults.length; i += PRACTICE_AVG_BLOCK_SIZE) {
                    const block = practiceResults.slice(i, i + PRACTICE_AVG_BLOCK_SIZE);
                    const blockStart = i + 1;
                    const blockEnd = Math.min(i + PRACTICE_AVG_BLOCK_SIZE, practiceResults.length);
                    
                    const blockData = calculateAverages(block);

                    txtData.push(`${practicePhaseName.replace(' ','_')}_Rounds_${blockStart}-${blockEnd}: Average Accuracy ${blockData.avgAccuracy}%`);
                }
                
                const overallPracticeData = calculateAverages(practiceResults);
                txtData.push(`\n${practicePhaseName.toUpperCase()}_OVERALL:`);
                txtData.push(`- Average Accuracy: ${overallPracticeData.avgAccuracy}%`);
                txtData.push(`- Average Speed: ${overallPracticeData.avgSpeed}s`);
            } else {
                txtData.push(`\n## PRACTICE DETAILS: No data recorded.`);
            }

            
            const test1PhaseName = 'Test 1';
            if (test1Results.length > 0) {
                const overallTest1Data = calculateAverages(test1Results);
                txtData.push(`\n## ${test1PhaseName.toUpperCase()} DETAILS`);
                txtData.push(`- Average Accuracy: ${overallTest1Data.avgAccuracy}%`);
                txtData.push(`- Average Speed: ${overallTest1Data.avgSpeed}s`);
            } else {
                txtData.push(`\n## ${test1PhaseName.toUpperCase()} DETAILS: No data recorded.`);
            }

            const test2PhaseName = 'Test 2';
            if (test2Results.length > 0) {
                const overallTest2Data = calculateAverages(test2Results);
                txtData.push(`\n## ${test2PhaseName.toUpperCase()} DETAILS`);
                txtData.push(`- Average Accuracy: ${overallTest2Data.avgAccuracy}%`);
                txtData.push(`- Average Speed: ${overallTest2Data.avgSpeed}s`);
            } else {
                txtData.push(`\n## ${test2PhaseName.toUpperCase()} DETAILS: No data recorded.`);
            }

            return txtData.join('\n');
        }

        // --- DOWNLOAD / DISPLAY FUNCTIONS (No changes here, copied from previous step) ---
        window.downloadResults = function(){
            const txtContent = window.generateResultsText();
            if(txtContent.includes("No results recorded")){
                alert('No results to download. Please complete a practice or test phase first.');
                return;
            }
            
            const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'motor_skill_results.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        window.displayResults = function(){
            const txtContent = window.generateResultsText();

            resultsDisplay.textContent = txtContent;
            resultsModal.style.display = 'flex'; // Show the modal
        }
    </script>
</body>
</html>
